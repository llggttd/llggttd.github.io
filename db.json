{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0},{"_id":"themes/landscape/source/js/jquery-2.0.3.js","path":"js/jquery-2.0.3.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"b279bd4a99704661b40f3992d87b2fd138b91e7d","modified":1430299691000},{"_id":"source/_drafts/Apache-重定向.md","shasum":"3e8790b056aacbbd4ebcb9ffc9f648cf817b56bf","modified":1430804001000},{"_id":"source/_posts/Android SDK国内镜像.md","shasum":"5255dd607679d3af7535b3100f2596d3d5bcf239","modified":1430715609000},{"_id":"source/_posts/Apache-AutoIndex-美化.md","shasum":"1a5de30a8b69da590226025b2c92753a29d8ade7","modified":1430715644000},{"_id":"source/_drafts/nginx.md","shasum":"1cc3bfb91f53b40dd3475ea367dcdb316221d477","modified":1430899695000},{"_id":"source/_posts/AndroidStudio代理设置.md","shasum":"7c06ca9e1f325569bc27f727c7cad5d9734d47c0","modified":1430878970000},{"_id":"source/_posts/Lua教程1.md","shasum":"a350ee789ff84aeedf59e81658fd50abefa89d99","modified":1430800900000},{"_id":"source/_posts/Lua教程2.md","shasum":"6df4c398ec7cf2b3315dd4adf3bdb2dea2c62c8c","modified":1430800900000},{"_id":"source/_posts/Lua教程3.md","shasum":"12572f252f189752193f3f84d913b46de4999a16","modified":1430800900000},{"_id":"source/_posts/使用Rsync.md","shasum":"f66407f32736653485e6c745706718d67568db13","modified":1430996586000},{"_id":"source/_posts/编译ffmpeg.md","shasum":"9fb1ad125b6adca451bb813fc74c2add000b8480","modified":1430997842000},{"_id":"source/_posts/Git教程.md","shasum":"5b766c9f9d029606099b78b9a157082fe19dff6b","modified":1430715659000},{"_id":"source/_posts/Mac下添加定时任务.md","shasum":"e9b74198493c0e43a97c07efb8a0ba9c613e54e3","modified":1430715669000},{"_id":"source/_posts/android_sdk.png","shasum":"79104de8bfa48d287e7e14b081ff5de1d4dab3a2","modified":1429777079000},{"_id":"source/_posts/重装安装Ubutnu.md","shasum":"2283cd55d1618fe66c068018c342cf38160df2db","modified":1430715581000},{"_id":"source/about/index.md","shasum":"dcc36b2c9723b7282bc6f3aa7e9d4b89b07bedd9","modified":1430714871000},{"_id":"themes/landscape/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1430296646000},{"_id":"themes/landscape/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","shasum":"22b8190dbadb6e6599b39b5a4c427aa38ef5ba93","modified":1430303925000},{"_id":"themes/landscape/layout/_partial/article.ejs","shasum":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1430716183000},{"_id":"themes/landscape/_config.yml","shasum":"50e4e8763cbdedb274d69730440e3868e8954da3","modified":1430714935000},{"_id":"themes/landscape/layout/_partial/archive.ejs","shasum":"d60e0500a13f673ecf13844a5214f100f6b0d25e","modified":1430800900000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/head.ejs","shasum":"78fbc47fc671a37078b0e5b6b9dff8985b691b45","modified":1430800900000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/footer.ejs","shasum":"7128cea15bf4e6c267ea9241fbc9dd9339e93c9b","modified":1430700478000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1430296646000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1430296646000},{"_id":"themes/landscape/layout/_widget/archive.ejs","shasum":"c37f59f1542678f6b6f2c980b54130e3a92c9baf","modified":1430700478000},{"_id":"themes/landscape/layout/_partial/header.ejs","shasum":"743a5eb3524d0cb5cf186a815fd0e3fcb4fd2c6d","modified":1430370888000},{"_id":"themes/landscape/layout/_widget/category.ejs","shasum":"017bab14cbee808fe96c865ef688a21b33eb1261","modified":1430700478000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","shasum":"4104c0a933e480ee9bbdd5b743f7ef439de80e07","modified":1430700478000},{"_id":"themes/landscape/layout/_widget/tag.ejs","shasum":"1ae755002b2aaab71c5885d64fe7885f0d66e21a","modified":1430700478000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","shasum":"c3fe5afa45d65efb655b5c5128100b3551fcb18f","modified":1430700478000},{"_id":"themes/landscape/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1430296646000},{"_id":"themes/landscape/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1430296646000},{"_id":"themes/landscape/layout/layout.ejs","shasum":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1430296646000},{"_id":"themes/landscape/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1430296646000},{"_id":"themes/landscape/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430296646000},{"_id":"themes/landscape/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430296646000},{"_id":"themes/landscape/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1430296646000},{"_id":"themes/landscape/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/article.styl","shasum":"2fce0e4d08044dae0bf41fba28d312df95ff13f0","modified":1430803409000},{"_id":"themes/landscape/package.json","shasum":"85358dc34311c6662e841584e206a4679183943f","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/archive.styl","shasum":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/footer.styl","shasum":"8544182c6c23a238b37e49393dfc8b696e5f4d2e","modified":1430365506000},{"_id":"themes/landscape/source/css/_extend.styl","shasum":"5712e48d1398815678068884ebf515940ad27d12","modified":1430372941000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","shasum":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","shasum":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","shasum":"b036fd29c02fc1afcdf71f05a4a43ecfd3ccdff2","modified":1430373308000},{"_id":"themes/landscape/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1430296646000},{"_id":"themes/landscape/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1430296646000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1430296646000},{"_id":"themes/landscape/source/css/_partial/header.styl","shasum":"560b811123e3e71894264aca14cbdc4ecdcb0a4f","modified":1430800900000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1430296646000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1430296646000},{"_id":"themes/landscape/source/css/_variables.styl","shasum":"945c7146e3fdca310e4cfce552f568a85a202f59","modified":1430800900000},{"_id":"themes/landscape/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1430296646000},{"_id":"themes/landscape/source/css/style.styl","shasum":"86b72a47f528a441578c355e2c9503b4ce1fbb17","modified":1430303620000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","shasum":"6ae0ed81bbfbb973d5d53c95cc28d6f20b8a97bf","modified":1430737348000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1430296646000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1430296646000},{"_id":"themes/landscape/source/js/script.js","shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1430296646000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1430296646000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1430296646000},{"_id":"themes/landscape/source/js/jquery-2.0.3.js","shasum":"ad73590c92b4c3f08d02a0751ba4e4aef658daa0","modified":1430303822000},{"_id":"public/CNAME","modified":1430996204417,"shasum":"b279bd4a99704661b40f3992d87b2fd138b91e7d"},{"_id":"public/js/script.js","modified":1430996204427,"shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1"},{"_id":"public/js/jquery-2.0.3.js","modified":1430996204430,"shasum":"ad73590c92b4c3f08d02a0751ba4e4aef658daa0"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1430996204431,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1430996204433,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1430996204434,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1430996204435,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1430996204436,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1430996204437,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1430996204438,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1430996204438,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1430996204440,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1430996204441,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1430996204442,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1430996204443,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1430996204444,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1430996204446,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1430996204447,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1430996205027,"shasum":"b6e04a5ae8919c01f626b4852970c148f8c49406"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1430996205167,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1430996205169,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1430996205171,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1430996205173,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1430996205175,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/about/index.html","modified":1431000121979,"shasum":"d4c7d2b9b1ad73cd66f783a9d195a59ed93bc178"},{"_id":"public/2015/05/07/使用Rsync/index.html","modified":1431000121999,"shasum":"91525ecadb8dbb4ff19ed16e4221493783ce6092"},{"_id":"public/2015/05/06/编译ffmpeg/index.html","modified":1431000122031,"shasum":"b45f0fa59bfc630be016aabe2c0e6b40109f0bee"},{"_id":"public/2015/05/06/AndroidStudio代理设置/index.html","modified":1431000122040,"shasum":"acd3739af1e58ac6f219acefe8453e14627ba4a6"},{"_id":"public/2015/05/04/Lua教程3/index.html","modified":1431000122060,"shasum":"37b49a78fb9382e04cdd0efe3df088e24f6890e4"},{"_id":"public/2015/05/04/Lua教程2/index.html","modified":1431000122076,"shasum":"87cea4336bd9631c2136fbf0f4e5ac648413e191"},{"_id":"public/2015/05/04/Lua教程1/index.html","modified":1431000122090,"shasum":"294e811e088597dc668110b56e7a66adbd884a6a"},{"_id":"public/2015/04/30/Apache-AutoIndex-美化/index.html","modified":1431000122097,"shasum":"b648c1160c0fb0a002090fa7bfc5c43afc635e41"},{"_id":"public/2015/04/29/重装安装Ubutnu/index.html","modified":1431000122105,"shasum":"f012d8f1a5f8376565b15b48f491ef11a342e7fb"},{"_id":"public/2015/04/29/Mac下添加定时任务/index.html","modified":1431000122120,"shasum":"a75e2a1488a6936a12cfb95a0cbee3612536d400"},{"_id":"public/2015/04/29/Android SDK国内镜像/index.html","modified":1431000122129,"shasum":"7a669137fc8f4d9f09f16bab4b1ac7721c75f958"},{"_id":"public/2015/04/29/Git教程/index.html","modified":1431000122140,"shasum":"28cedd3017c908118134d2ceda49267d327cc0aa"},{"_id":"public/archives/index.html","modified":1431000122158,"shasum":"94334f5a923cdeb200ad8f3feb7aa6d0d66aa985"},{"_id":"public/archives/page/2/index.html","modified":1431000122171,"shasum":"d3ef6c51dfcc2dc51262a471e76c292912aab4ec"},{"_id":"public/archives/2015/index.html","modified":1431000122192,"shasum":"4f9ed7ad1e5e20459f0dbb0160217e8b93a99615"},{"_id":"public/archives/2015/page/2/index.html","modified":1431000122206,"shasum":"53b85edf380ddb487765af7659f04933a89b2829"},{"_id":"public/archives/2015/04/index.html","modified":1431000122219,"shasum":"4241da8cfc0f9558adc84e3d65875f09334b7fc5"},{"_id":"public/archives/2015/05/index.html","modified":1431000122233,"shasum":"0a7f13da148dd6fafa69be208fb0718e2969c83e"},{"_id":"public/categories/系统/index.html","modified":1431000122349,"shasum":"8c083b309796b5728712724fa1d528b4920e04b4"},{"_id":"public/categories/系统/Ubuntu/index.html","modified":1431000122360,"shasum":"24d9dabe40e56cb64abfaaf301387f34047ef821"},{"_id":"public/categories/工具/index.html","modified":1431000122378,"shasum":"57ba6ec1d455a3067cd77939c4ca022dc5fde2e7"},{"_id":"public/categories/工具/rsync/index.html","modified":1431000122387,"shasum":"12867086b0cca328199ebf17627eae641ea38325"},{"_id":"public/categories/系统/Mac/index.html","modified":1431000122399,"shasum":"9ef6e2a581e9b399802ac20b76361684b26715b9"},{"_id":"public/categories/语言/index.html","modified":1431000122410,"shasum":"329706a8c70545eace3a1e109dbac4822e37c022"},{"_id":"public/categories/语言/LUA/index.html","modified":1431000122421,"shasum":"d88ff5225baf5c9bc8e2d5ac69550605bd3f4109"},{"_id":"public/categories/工具/Git/index.html","modified":1431000122431,"shasum":"587614f7e5b0d784a7196be914104aba5b1e817c"},{"_id":"public/categories/服务器/index.html","modified":1431000122439,"shasum":"89e3f06449b275c6f2e419f4ad3e172dadcb1cf9"},{"_id":"public/categories/Android/index.html","modified":1431000122449,"shasum":"2396180eff986a84a2a15433da93c8ba1ad0016a"},{"_id":"public/index.html","modified":1431000122259,"shasum":"3f08e454903e168f958bf460edbce981a63c201b"},{"_id":"public/page/2/index.html","modified":1431000122331,"shasum":"b6d6ae8e27263d03c9487ee489cf5ece83cc2f3a"},{"_id":"source/_posts/BootingInInsecureMode.md","shasum":"c8f1de95c8d90c8ee4c927d797a3819094c33c30","modified":1431000245000},{"_id":"public/2015/05/06/BootingInInsecureMode/index.html","modified":1431000122010,"shasum":"d80207e7663ba4a260441be2114e9611dea13236"},{"_id":"public/archives/2015/05/page/2/index.html","modified":1431000122238,"shasum":"8e7effc4e76d9c1be4e7b38e035b3b5225ca32d4"}],"Category":[{"name":"系统","_id":"ci9e26vrz0002f2arivo64fd4"},{"name":"Ubuntu","parent":"ci9e26vrz0002f2arivo64fd4","_id":"ci9e26vs10003f2arwpug281o"},{"name":"工具","_id":"ci9e26vse0008f2arhmpw9tsh"},{"name":"rsync","parent":"ci9e26vse0008f2arhmpw9tsh","_id":"ci9e26vse0009f2aramollh1h"},{"name":"Mac","parent":"ci9e26vrz0002f2arivo64fd4","_id":"ci9e26vsm000df2arbjecx9kg"},{"name":"语言","_id":"ci9e26wjg000hf2ar4y5o1wad"},{"name":"LUA","parent":"ci9e26wjg000hf2ar4y5o1wad","_id":"ci9e26wjg000if2arteylr43j"},{"name":"Git","parent":"ci9e26vse0008f2arhmpw9tsh","_id":"ci9e26wrc000sf2arb7sljylo"},{"name":"服务器","_id":"ci9e26wrg000wf2arnswgupr7"},{"name":"Android","_id":"ci9e26ws4000zf2arw3dg518w"}],"Data":[],"Page":[{"title":"about","date":"2015-05-04T04:47:51.000Z","_content":"","source":"about/index.md","raw":"title: \"about\"\ndate: 2015-05-04 12:47:51\n---\n","updated":"2015-05-04T04:47:51.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ci9e26vr00000f2ar8glfpu4t"}],"Post":[{"title":"Ubuntu下重新安装Ubuntu","date":"2015-04-29T07:30:00.000Z","updated":"2015-04-29T23:30:00.000Z","layout":"post","comments":1,"_content":"\n## 通过grub引导ubuntu镜像文件来安装系统\n\n下载了ubuntu的镜像文件，如何安装? 如果你还有光盘刻录设备，可以把ubuntu系统镜像刻录到光盘来进行安装，但现在很少人还在用有光驱的机器了吧。你也可以使用工具（windows下有ultraiso, ubuntu下有startup disk creater)把光盘镜像写入到u盘，通过u盘来安装。其实不用这么麻烦，镜像文件不是已经下载到你的硬盘了吗，我们可以直接从硬盘来安装系统。\n\n*本安装方法，仅适用于已经有grub2引导环境的情况*\n\n- 准备iso镜像文件\n\n    ubuntu最新发行版下载地址：[ubuntu](http://releases.ubuntu.com/)\n\n- 拷贝iso文件到指定目录\n\n    把iso文件拷贝到一个路径相对简洁一些的目录。因为在grub下你要用到这个目录， 太长了输起来麻烦。比如放在：/boot/下。\n    *注意不要放在中文目录中，在grub下，你是无法输入中文的*\n\n- 引导iso\n\n    + 如果你现在的系统是ubuntu, 可以通过修改文件/etc/grub.d/40-custom来添加启动项。\n    打开40-custom, 输入以下内容：\n\n    ``` sh\n    menuentry \"ISO\" {\n        set isofile=\"/boot/iso/ubuntu-15.04-desktop-amd64.iso\"\n        loopback loop (hd0, 1)$isofile\n        linux (loop)/casper/vmlinuz.efi boot=casper iso-scan/filename=$isofile\n        initrd (loop)/casper/initrd\n    }\n    ```\n    上面isofile是光盘镜像的位置，根据自己的情况进行设置。\n\n    对上面几个命令的说明：\n\n        - menuentry\n\n        设定启动菜单的标题，也就是在grub启动选择菜单中看到的内容\n\n        - set isofile\n\n        设置变量isofile, 指向iso镜像文件的路径， 因为iso的路径比较长，设置变量方便其它地方的输入\n\n        - loopback\n\n        挂载镜像文件，这里要指明镜像文件的绝对路径。\n        (hd0, 4)表示硬盘0的4号分区， 可以通过命令df查看自己电脑上的具体情况\n\n        - linux\n\n        指定要搜索镜像的路径和要加载的内核路径\n\n        - initrd\n\n        初始化临时的根文件系统\n        \n    然后运行sudo update-grub来重新生成启动菜单。重启电脑，进入grub的启动菜单，就可以看到ISO的启动项了。\n\n    + 如果不想添加启动项， 也可以直接在grub的命令环境下手动引导\n\n    开机重启后，按住shift键直到进入grub菜单界面，再按C进入命令行模式。\n\n    把上面启动菜单项的命令，在这里执行一遍。\n","source":"_posts/重装安装Ubutnu.md","raw":"title: \"Ubuntu下重新安装Ubuntu\"\ndate: 2015-04-29 15:30:00\nupdated: 2015-04-30 07:30:00\nlayout: post\ncomments:   true\ncategories:\n- 系统\n- Ubuntu\n---\n\n## 通过grub引导ubuntu镜像文件来安装系统\n\n下载了ubuntu的镜像文件，如何安装? 如果你还有光盘刻录设备，可以把ubuntu系统镜像刻录到光盘来进行安装，但现在很少人还在用有光驱的机器了吧。你也可以使用工具（windows下有ultraiso, ubuntu下有startup disk creater)把光盘镜像写入到u盘，通过u盘来安装。其实不用这么麻烦，镜像文件不是已经下载到你的硬盘了吗，我们可以直接从硬盘来安装系统。\n\n*本安装方法，仅适用于已经有grub2引导环境的情况*\n\n- 准备iso镜像文件\n\n    ubuntu最新发行版下载地址：[ubuntu](http://releases.ubuntu.com/)\n\n- 拷贝iso文件到指定目录\n\n    把iso文件拷贝到一个路径相对简洁一些的目录。因为在grub下你要用到这个目录， 太长了输起来麻烦。比如放在：/boot/下。\n    *注意不要放在中文目录中，在grub下，你是无法输入中文的*\n\n- 引导iso\n\n    + 如果你现在的系统是ubuntu, 可以通过修改文件/etc/grub.d/40-custom来添加启动项。\n    打开40-custom, 输入以下内容：\n\n    ``` sh\n    menuentry \"ISO\" {\n        set isofile=\"/boot/iso/ubuntu-15.04-desktop-amd64.iso\"\n        loopback loop (hd0, 1)$isofile\n        linux (loop)/casper/vmlinuz.efi boot=casper iso-scan/filename=$isofile\n        initrd (loop)/casper/initrd\n    }\n    ```\n    上面isofile是光盘镜像的位置，根据自己的情况进行设置。\n\n    对上面几个命令的说明：\n\n        - menuentry\n\n        设定启动菜单的标题，也就是在grub启动选择菜单中看到的内容\n\n        - set isofile\n\n        设置变量isofile, 指向iso镜像文件的路径， 因为iso的路径比较长，设置变量方便其它地方的输入\n\n        - loopback\n\n        挂载镜像文件，这里要指明镜像文件的绝对路径。\n        (hd0, 4)表示硬盘0的4号分区， 可以通过命令df查看自己电脑上的具体情况\n\n        - linux\n\n        指定要搜索镜像的路径和要加载的内核路径\n\n        - initrd\n\n        初始化临时的根文件系统\n        \n    然后运行sudo update-grub来重新生成启动菜单。重启电脑，进入grub的启动菜单，就可以看到ISO的启动项了。\n\n    + 如果不想添加启动项， 也可以直接在grub的命令环境下手动引导\n\n    开机重启后，按住shift键直到进入grub菜单界面，再按C进入命令行模式。\n\n    把上面启动菜单项的命令，在这里执行一遍。\n","slug":"重装安装Ubutnu","published":1,"photos":[],"link":"","_id":"ci9e26vrw0001f2ar9likt6d1"},{"title":"编译可供Android使用的FFmpeg库","date":"2015-05-06T06:23:42.000Z","_content":"\nFFmpeg是一套强大的音、视频处理工具。常用来对音频、视频进行合并或分离、拼接、剪裁，音频视频的转码等，还有非常强大的视频采集、视频抓图、给视频加水印等功能。主要组件：\n- libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构\n和读取音视频帧等功能；\n- libavcodec：用于各种类型声音/图像编解码；\n- libavutil：包含一些公共的工具函数；\n- libswscale：用于视频场景比例缩放、色彩映射转换；\n- libpostproc：用于后期效果处理；\n- ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；\n- ffsever：一个 HTTP 多媒体即时广播串流服务器；\n- ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；\n\n## 编译FFmpeg\n\n+ 下载[ffmpeg]()\n\n本测试使用的版本为2.6.1， 使用其它版本时请灵活变通\n\n+ 编译成互相独立的动态库\n\nffmpeg的每一个组件单独编译成.so库，通过android的jni技术，使用c调用这些.so库中的方法，\n实现我们想要的功能。\n\n``` sh\n#!/bin/sh\n# NDK的路径，根据自己的安装位置进行设置\nNDK=/Users/uniflor/Apps/android-ndk\nPLATFORM=$NDK/platforms/android-14/arch-arm\n# 工具链的路径，根据编译的平台不同而不同\nTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64\n\nCPU=arm\nPREFIX=$(pwd)/android/$CPU\nADDI_CFLAGS=\"-marm\"\nADDITIONAL_CONFIGURE_FLAG=\n\n./configure \\\n    --enable-shared \\\n    --disable-static \\\n    --disable-doc \\\n    --disable-ffplay \\\n    --disable-ffprobe \\\n    --disable-ffserver \\\n    --disable-symver \\\n    --disable-avdevice \\\n    --disable-protocols \\\n    --enable-protocol=file \\\n    --disable-doc \\\n    --enable-cross-compile \\\n    --prefix=$PREFIX \\\n    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n    --target-os=linux \\\n    --arch=arm \\\n    --sysroot=$PLATFORM \\\n    --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\\n    --extra-ldflags=\"$ADDI_LDFLAGS\"\n```\n\n等待几分钟，命令运行结束后会在ffmpeg目录下生成一个anroid/arm的目录，\n目录中会有提取的头文件和动态库。\n生成以下动态库如下：\n- libavcodec.so\n- libavdevice.so\n- libavfilter.so\n- libavformat.so\n- libavutil.so\n- libswresample.so\n- libswscale.so\n\n每个库的作用，请自行百度或google, 生的动态库要进行精简或扩展功能的请参考ffmpeg官方文档来\n调整上面的configure的参数。\n\n+ 编译libffmpeg.so\n\n如果感觉生成的库太多，调用时一一加载麻烦，可以把这些库合并成一个库。\n\n``` sh\n#!/bin/sh\n# NDK的路径，根据自己的安装位置进行设置\nNDK=/Users/uniflor/Apps/android-ndk\nPLATFORM=$NDK/platforms/android-14/arch-arm\n# 工具链的路径，根据编译的平台不同而不同\nTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64\n\nCPU=arm\nPREFIX=$(pwd)/android/$CPU\nADDI_CFLAGS=\"-marm\"\nADDITIONAL_CONFIGURE_FLAG=\n\n./configure \\\n    --disable-doc \\\n    --disable-ffmpeg \\\n    --disable-ffplay \\\n    --disable-ffprobe \\\n    --disable-ffserver \\\n    --disable-symver \\\n    --disable-doc \\\n    --enable-cross-compile \\\n    --prefix=$PREFIX \\\n    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n    --target-os=linux \\\n    --arch=arm \\\n    --sysroot=$PLATFORM \\\n    --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\\n    --extra-ldflags=\"$ADDI_LDFLAGS\" \\\n\nmake clean\nmake\nmake install\n\n# 合并生成的静态库\n\n$TOOLCHAIN/bin/arm-linux-androideabi-ld \\\n    -rpath-link=$PLATFORM/usr/lib \\\n    -L$PLATFORM/usr/lib \\\n    -soname libffmpeg.so \\\n    -shared -nostdlib  \\\n    -Bsymbolic \\\n    --whole-archive --no-undefined \\\n    -o $PREFIX/libffmpeg.so \\\n    libavcodec/libavcodec.a \\\n    libavfilter/libavfilter.a \\\n    libswresample/libswresample.a \\\n    libavformat/libavformat.a \\\n    libavutil/libavutil.a \\\n    libswscale/libswscale.a \\\n    -lc -lm -lz -ldl -llog \\\n    $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9/libgcc.a\n```\n\n等待几分钟，命令运行结束后会在ffmpeg目录下生成一个anroid/arm的目录, 目录中会有提取的头文件和生成的libffmpeg.so库。\n\n\n## 以命令行的形式来使用ffmpeg\n\n在编译ffmpeg时，使用了参数 --disable-ffmpeg， 是不会生成ffmpeg工具的，不过生成了，\n在android应用下也无法直接使用。但我们可以使用jni技术，间接调用ffmpeg的命令行方式。\n\n- 为android项目创建jni文件夹\n\n    创建jni文件夹，添加文件Android.mk和Application.mk\n\n- 添加Application.mk文件\n\n    内容如下：\n\n``` makefile\nAPP_ABI := armeabi\nAPP_ABI += armeabi-v7a\nAPP_PLATFORM := android-14\n```\n\n- 复制ffmpeg文件\n\n复制上面android文件夹下的头文件文件夹include和ffmpeg.h, ffmpeg.c, ffmpeg_opt.c, ffmpeg_filter.c，\ncmdutils.c, cmdutils.h, cmdutils_common_opts.h, config.h, libffmpeg.so到jni目录下\n\n- 修改ffmpeg.c和ffmpeg.h\n\n找到ffmpeg.c，把int man(int argc, char **argv)改名为\nint run(int argc, char **argv)\n\n找到ffmpeg.h, 在文件末尾添加函数申明: int run(int argc, char **argv);\n\n- 修改cmdutils.c\n\n找到cmdutils.c中的exit_program函数，注释到 exit(ret), 添加 return ret；\n并修改函数的返回类型为int, 找到cmdutils.h中exit_program的申明，也把返回类型修改为int。\n\n- 生成接口文件com.example.ffmpeg.FFmpegKit.java\n\n``` java\npackage com.example.ffmpeg;\n\nimport java.util.ArrayList;\n\npublic class FFmpegKit {\n    \n    private ArrayList<String> commands;\n    \n    \n    public FFmpegKit() {\n        this.commands = new ArrayList<String>();\n        this.commands.add(\"ffmpeg\");\n    }\n\n    public native static int run(String[] commands);\n}\n```\n\n- 生成头文件com_example_ffmpeg_FFmpegKit.h\n\n使用javah生成\n\n- 添加com_example_ffmpeg_FFmpegKit.c\n\n``` c\n#include \"com_example_ffmpeg_FFmpegKit.h\"\n#include \"ffmpeg.h\"\n#include <string.h>\n\n\n/*\n * Class:     com_example_ffmpeg_FFmpegKit\n * Method:    run\n * Signature: (Ljava/lang/String;)I\n */\nJNIEXPORT jint JNICALL Java_com_example_ffmpeg_FFmpegKit_run(JNIEnv *env,\n        jclass obj, jobjectArray commands) {\n\n    int argc = (*env)->GetArrayLength(env, commands);\n    char *argv[argc];\n\n    __android_log_print(ANDROID_LOG_ERROR,\"Kit\",\"argc %d\\n\", argc);\n    int i;\n    for (i = 0; i < argc; i++) {\n        jstring js = (jstring) (*env)->GetObjectArrayElement(env, commands, i);\n        argv[i] = (char*) (*env)->GetStringUTFChars(env, js, 0);\n        __android_log_print(ANDROID_LOG_ERROR,\"Kit\",\"argv %s\\n\", argv[i]);\n    }\n    return run(argc, argv);\n}\n```\n\nAndroid.mk文件内空为\n\n``` makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := ffmpeg\nLOCAL_SRC_FILES := libffmpeg.so\ninclude $(PREBUILT_SHARED_LIBRARY)\n\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := ffmpeginvoke\nLOCAL_SRC_FILES := com_example_ffmpeg_FFmpegKit.c ffmpeg.c ffmpeg_opt.c cmdutils.c ffmpeg_filter.c\nLOCAL_C_INCLUDES := $(LOCAL_PATH)\nLOCAL_LDLIBS := -llog -lz -ldl\nLOCAL_SHARED_LIBRARIES := ffmpeg\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n- 编译接口\n\n\n- 测试接口\n\n``` java\npublic class MainActivity extends Activity {\n\n    static {\n        System.loadLibrary(\"ffmpeg\");\n        System.loadLibrary(\"ffmpeginvoke\");\n    }\n    \n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        String base = Environment.getExternalStorageDirectory().getPath();\n        Log.e(\"PATH\", base);\n        String[] commands = new String[9];\n        commands[0] = \"ffmpeg\";\n        commands[1] = \"-i\";\n        commands[2] = base + \"/input.mp4\";\n        commands[3] = \"-i\";\n        commands[4] = base + \"/input.mp3\";\n        commands[5] = \"-strict\";\n        commands[6] = \"-2\";\n        commands[7] = \"-y\";\n        commands[8] = base + \"/merge.mp4\";\n        int result = FFmpegKit.run(commands);\n        Log.e(\"RESULT\", result + \"**********************\");\n    }\n}\n```\n","source":"_posts/编译ffmpeg.md","raw":"title: \"编译可供Android使用的FFmpeg库\"\ndate: 2015-05-06 14:23:42\ntags:\ncategories:\n- Android\n---\n\nFFmpeg是一套强大的音、视频处理工具。常用来对音频、视频进行合并或分离、拼接、剪裁，音频视频的转码等，还有非常强大的视频采集、视频抓图、给视频加水印等功能。主要组件：\n- libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构\n和读取音视频帧等功能；\n- libavcodec：用于各种类型声音/图像编解码；\n- libavutil：包含一些公共的工具函数；\n- libswscale：用于视频场景比例缩放、色彩映射转换；\n- libpostproc：用于后期效果处理；\n- ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；\n- ffsever：一个 HTTP 多媒体即时广播串流服务器；\n- ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；\n\n## 编译FFmpeg\n\n+ 下载[ffmpeg]()\n\n本测试使用的版本为2.6.1， 使用其它版本时请灵活变通\n\n+ 编译成互相独立的动态库\n\nffmpeg的每一个组件单独编译成.so库，通过android的jni技术，使用c调用这些.so库中的方法，\n实现我们想要的功能。\n\n``` sh\n#!/bin/sh\n# NDK的路径，根据自己的安装位置进行设置\nNDK=/Users/uniflor/Apps/android-ndk\nPLATFORM=$NDK/platforms/android-14/arch-arm\n# 工具链的路径，根据编译的平台不同而不同\nTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64\n\nCPU=arm\nPREFIX=$(pwd)/android/$CPU\nADDI_CFLAGS=\"-marm\"\nADDITIONAL_CONFIGURE_FLAG=\n\n./configure \\\n    --enable-shared \\\n    --disable-static \\\n    --disable-doc \\\n    --disable-ffplay \\\n    --disable-ffprobe \\\n    --disable-ffserver \\\n    --disable-symver \\\n    --disable-avdevice \\\n    --disable-protocols \\\n    --enable-protocol=file \\\n    --disable-doc \\\n    --enable-cross-compile \\\n    --prefix=$PREFIX \\\n    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n    --target-os=linux \\\n    --arch=arm \\\n    --sysroot=$PLATFORM \\\n    --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\\n    --extra-ldflags=\"$ADDI_LDFLAGS\"\n```\n\n等待几分钟，命令运行结束后会在ffmpeg目录下生成一个anroid/arm的目录，\n目录中会有提取的头文件和动态库。\n生成以下动态库如下：\n- libavcodec.so\n- libavdevice.so\n- libavfilter.so\n- libavformat.so\n- libavutil.so\n- libswresample.so\n- libswscale.so\n\n每个库的作用，请自行百度或google, 生的动态库要进行精简或扩展功能的请参考ffmpeg官方文档来\n调整上面的configure的参数。\n\n+ 编译libffmpeg.so\n\n如果感觉生成的库太多，调用时一一加载麻烦，可以把这些库合并成一个库。\n\n``` sh\n#!/bin/sh\n# NDK的路径，根据自己的安装位置进行设置\nNDK=/Users/uniflor/Apps/android-ndk\nPLATFORM=$NDK/platforms/android-14/arch-arm\n# 工具链的路径，根据编译的平台不同而不同\nTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64\n\nCPU=arm\nPREFIX=$(pwd)/android/$CPU\nADDI_CFLAGS=\"-marm\"\nADDITIONAL_CONFIGURE_FLAG=\n\n./configure \\\n    --disable-doc \\\n    --disable-ffmpeg \\\n    --disable-ffplay \\\n    --disable-ffprobe \\\n    --disable-ffserver \\\n    --disable-symver \\\n    --disable-doc \\\n    --enable-cross-compile \\\n    --prefix=$PREFIX \\\n    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n    --target-os=linux \\\n    --arch=arm \\\n    --sysroot=$PLATFORM \\\n    --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\\n    --extra-ldflags=\"$ADDI_LDFLAGS\" \\\n\nmake clean\nmake\nmake install\n\n# 合并生成的静态库\n\n$TOOLCHAIN/bin/arm-linux-androideabi-ld \\\n    -rpath-link=$PLATFORM/usr/lib \\\n    -L$PLATFORM/usr/lib \\\n    -soname libffmpeg.so \\\n    -shared -nostdlib  \\\n    -Bsymbolic \\\n    --whole-archive --no-undefined \\\n    -o $PREFIX/libffmpeg.so \\\n    libavcodec/libavcodec.a \\\n    libavfilter/libavfilter.a \\\n    libswresample/libswresample.a \\\n    libavformat/libavformat.a \\\n    libavutil/libavutil.a \\\n    libswscale/libswscale.a \\\n    -lc -lm -lz -ldl -llog \\\n    $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9/libgcc.a\n```\n\n等待几分钟，命令运行结束后会在ffmpeg目录下生成一个anroid/arm的目录, 目录中会有提取的头文件和生成的libffmpeg.so库。\n\n\n## 以命令行的形式来使用ffmpeg\n\n在编译ffmpeg时，使用了参数 --disable-ffmpeg， 是不会生成ffmpeg工具的，不过生成了，\n在android应用下也无法直接使用。但我们可以使用jni技术，间接调用ffmpeg的命令行方式。\n\n- 为android项目创建jni文件夹\n\n    创建jni文件夹，添加文件Android.mk和Application.mk\n\n- 添加Application.mk文件\n\n    内容如下：\n\n``` makefile\nAPP_ABI := armeabi\nAPP_ABI += armeabi-v7a\nAPP_PLATFORM := android-14\n```\n\n- 复制ffmpeg文件\n\n复制上面android文件夹下的头文件文件夹include和ffmpeg.h, ffmpeg.c, ffmpeg_opt.c, ffmpeg_filter.c，\ncmdutils.c, cmdutils.h, cmdutils_common_opts.h, config.h, libffmpeg.so到jni目录下\n\n- 修改ffmpeg.c和ffmpeg.h\n\n找到ffmpeg.c，把int man(int argc, char **argv)改名为\nint run(int argc, char **argv)\n\n找到ffmpeg.h, 在文件末尾添加函数申明: int run(int argc, char **argv);\n\n- 修改cmdutils.c\n\n找到cmdutils.c中的exit_program函数，注释到 exit(ret), 添加 return ret；\n并修改函数的返回类型为int, 找到cmdutils.h中exit_program的申明，也把返回类型修改为int。\n\n- 生成接口文件com.example.ffmpeg.FFmpegKit.java\n\n``` java\npackage com.example.ffmpeg;\n\nimport java.util.ArrayList;\n\npublic class FFmpegKit {\n    \n    private ArrayList<String> commands;\n    \n    \n    public FFmpegKit() {\n        this.commands = new ArrayList<String>();\n        this.commands.add(\"ffmpeg\");\n    }\n\n    public native static int run(String[] commands);\n}\n```\n\n- 生成头文件com_example_ffmpeg_FFmpegKit.h\n\n使用javah生成\n\n- 添加com_example_ffmpeg_FFmpegKit.c\n\n``` c\n#include \"com_example_ffmpeg_FFmpegKit.h\"\n#include \"ffmpeg.h\"\n#include <string.h>\n\n\n/*\n * Class:     com_example_ffmpeg_FFmpegKit\n * Method:    run\n * Signature: (Ljava/lang/String;)I\n */\nJNIEXPORT jint JNICALL Java_com_example_ffmpeg_FFmpegKit_run(JNIEnv *env,\n        jclass obj, jobjectArray commands) {\n\n    int argc = (*env)->GetArrayLength(env, commands);\n    char *argv[argc];\n\n    __android_log_print(ANDROID_LOG_ERROR,\"Kit\",\"argc %d\\n\", argc);\n    int i;\n    for (i = 0; i < argc; i++) {\n        jstring js = (jstring) (*env)->GetObjectArrayElement(env, commands, i);\n        argv[i] = (char*) (*env)->GetStringUTFChars(env, js, 0);\n        __android_log_print(ANDROID_LOG_ERROR,\"Kit\",\"argv %s\\n\", argv[i]);\n    }\n    return run(argc, argv);\n}\n```\n\nAndroid.mk文件内空为\n\n``` makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := ffmpeg\nLOCAL_SRC_FILES := libffmpeg.so\ninclude $(PREBUILT_SHARED_LIBRARY)\n\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := ffmpeginvoke\nLOCAL_SRC_FILES := com_example_ffmpeg_FFmpegKit.c ffmpeg.c ffmpeg_opt.c cmdutils.c ffmpeg_filter.c\nLOCAL_C_INCLUDES := $(LOCAL_PATH)\nLOCAL_LDLIBS := -llog -lz -ldl\nLOCAL_SHARED_LIBRARIES := ffmpeg\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n- 编译接口\n\n\n- 测试接口\n\n``` java\npublic class MainActivity extends Activity {\n\n    static {\n        System.loadLibrary(\"ffmpeg\");\n        System.loadLibrary(\"ffmpeginvoke\");\n    }\n    \n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        String base = Environment.getExternalStorageDirectory().getPath();\n        Log.e(\"PATH\", base);\n        String[] commands = new String[9];\n        commands[0] = \"ffmpeg\";\n        commands[1] = \"-i\";\n        commands[2] = base + \"/input.mp4\";\n        commands[3] = \"-i\";\n        commands[4] = base + \"/input.mp3\";\n        commands[5] = \"-strict\";\n        commands[6] = \"-2\";\n        commands[7] = \"-y\";\n        commands[8] = base + \"/merge.mp4\";\n        int result = FFmpegKit.run(commands);\n        Log.e(\"RESULT\", result + \"**********************\");\n    }\n}\n```\n","slug":"编译ffmpeg","published":1,"updated":"2015-05-07T11:24:02.000Z","_id":"ci9e26vs80006f2armec0wvt3","comments":1,"layout":"post","photos":[],"link":""},{"title":"使用Rsync","date":"2015-05-07T02:55:10.000Z","_content":"\n## rsync 命令\n\n### rsync的命令格式可以为以下六种：\n\n- rsync [OPTION]... SRC [SRC]... DEST\n\n本地文件同步，即SRC和DES在同一台机器上。SRC可以指定多个目录或文件。如:\n\n``` sh\nrsync -arv ~/www /var/www\n```\n\n- rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n\n使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。\nDEST有两种写法：相对当前用户家目录的路径和绝对路径。如:\n\n``` sh\nrsync -arv test ozone@crazyman.top:temp\nrsync -arv test ozone@crazyman.top:/home/ozone/temp\n```\n\n- rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n\n从本地机器拷贝文件到远程rsync服务器中。\nDEST此时不再是路径，而是再服务器上rsync配置的模块名称。rsync的具体配置以后我会详细讲解。\n如：\n\n``` sh\nrsync -arv test ozone@crazyman.top::www\n```\n\n- rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n\n从本地机器拷贝文件到远程rsync服务器中。和使用\"rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\"相同， 此时的DEST也是模块名称，不是路径。如：\n\n``` sh\nrsync -arv test rsync://ozone@crazyman.top/www\n```\n\n- rsync [OPTION]... [USER@]HOST:SRC [DEST]\n\n使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。SRC有两种写法：相对当前用户家目录的路径和绝对路径。当DEST省略时，只显示远程文件列表，不进行实际的拷贝工作。如:\n\n``` sh\nrsync -arv ozone@crazyman.top:temp test \nrsync -arv ozone@crazyman.top:/home/ozone/temp test \n```\n\n- rsync [OPTION]... [USER@]HOST::SRC [DEST]\n\n从远程rsync服务器中拷贝文件到本地机。SRC此时不再是路径，而是再服务器上rsync配置的模块名称。如：\n\n``` sh\nrsync -arv ozone@crazyman.top::www test\n```\n\n- rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n\n从远程rsync服务器中拷贝文件到本地机。和使用\"rsync [OPTION]... [USER@]HOST::SRC [DEST]\"相同， 此时的DEST也是模块名称，不是路径。如：\n\n``` sh\nrsync -arv rsync://ozone@crazyman.top/www test\n```\n\n几个需要注意的地方：\n\n- 从本地拷贝文件到远程计算机时，SRC可以指定多个\n- 当DEST为本地路径时，DEST参数可以省略，省略时只会显示文件列表，不执行实际的同步工作，这在确认远程路径内容时非常有用\n- 使用\":\"时，实际是通过remote shell连接，远程服务器不需要启动rsync服务。 使用\"::\"或\"rsync:\"时，连接到的是rysnc daemon, 所以这时要指定模块的名称\n\n### rsync 命令参数\n\nrsync参数很多，常用的参数如下：\n\n- -v, --verbose                 详细模式输出\n- -q, --quiet                   精简输出模式\n- -q, --no-motd                 不显示欢迎信息\n- -a, --archive                 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD\n- -a, --no-OPTION               关闭-a中打开的某个选项(e.g. --no-D)\n- -r, --recursive               对子目录以递归模式处理\n- -d, --dirs                    只拷贝文件夹\n- -R, --relative                使用相对路径信息\n- 更新\n    + -u, --update  跳过所有已经存在于DST，并且文件时间晚于要备份的文件\n    + -u, --inplace\n    + -u, --append\n    + -u, --append-verify\n\n- 文件备份\n    + -b, --backup                  创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。\n    + --backup-dir=DIR              将备份文件(如~filename)存放在在目录下。\n    + --suffix=SUFFIX               定义备份文件前缀\n\n- 链接处理\n    + -l, --links                   保留软链结\n    + -L, --copy-links              想对待常规文件一样处理软链结\n    + --copy-unsafe-links           仅仅拷贝指向SRC路径目录树以外的链结\n    + --safe-links                  忽略指向SRC路径目录树以外的链结\n    + -H, --hard-links              保留硬链结\n    + -k, --copy-dirlinks           把文件夹链接拷贝成一个链接文件\n    + -K, --keep-dirlinks           把文件夹链接拷贝成一个文件夹\n\n- 文件属性\n    + -A, --acls                    保持ACLs\n    + -X, --xattrs                  保持扩展属性\n    + -p, --perms                   保持文件权限\n    + -o, --owner                   保持文件属主信息\n    + -g, --group                   保持文件属组信息\n    + -D, --devices                 保持设备文件信息\n    + -t, --times                   保持文件时间信息\n\n- -S, --sparse                      对稀疏文件进行特殊处理以节省DST的空间\n- -n, --dry-run                     现实哪些文件将被传输\n- -W, --whole-file                  拷贝文件，不进行增量检测\n- -x, --one-file-system             不要跨越文件系统边界\n- -c, --checksum                    打开校验开关，强制对文件传输进行校验\n- -B, --block-size=SIZE             检验算法使用的块尺寸，默认是700字节\n\n- 文件排除\n    + -C, --cvs-exclude                 使用和CVS一样的方法自动忽略文件\n    + --exclude=PATTERN                 指定排除不需要传输的文件模式\n    + --include=PATTERN                 指定不排除而需要传输的文件模式\n    + --exclude-from=FILE               排除FILE中指定模式的文件\n    + --include-from=FILE               不排除FILE指定模式匹配的文件\n\n- --config=FILE                         指定其他的配置文件，不使用默认的rsyncd.conf文件\n- --password-file=FILE                  从FILE中得到密码\n- -z, --compress                        对备份的文件在传输时进行压缩处理\n- - --progress                            在传输时现实传输过程\n- --existing                            仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件\n- --delete                              删除那些DST中有SRC没有的文件\n--delete-excluded                       同样删除接收端那些被该选项指定排除的文件\n--delete-after                          传输结束以后再删除\n--ignore-errors                         及时出现IO错误也进行删除\n--partial                               保留那些因故没有完全传输的文件，以是加快随后的再次传输\n--force                                 强制删除目录，即使不为空","source":"_posts/使用Rsync.md","raw":"title: \"使用Rsync\"\ndate: 2015-05-07 10:55:10\ntags:\ncategories:\n- 工具\n- rsync\n---\n\n## rsync 命令\n\n### rsync的命令格式可以为以下六种：\n\n- rsync [OPTION]... SRC [SRC]... DEST\n\n本地文件同步，即SRC和DES在同一台机器上。SRC可以指定多个目录或文件。如:\n\n``` sh\nrsync -arv ~/www /var/www\n```\n\n- rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n\n使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。\nDEST有两种写法：相对当前用户家目录的路径和绝对路径。如:\n\n``` sh\nrsync -arv test ozone@crazyman.top:temp\nrsync -arv test ozone@crazyman.top:/home/ozone/temp\n```\n\n- rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n\n从本地机器拷贝文件到远程rsync服务器中。\nDEST此时不再是路径，而是再服务器上rsync配置的模块名称。rsync的具体配置以后我会详细讲解。\n如：\n\n``` sh\nrsync -arv test ozone@crazyman.top::www\n```\n\n- rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n\n从本地机器拷贝文件到远程rsync服务器中。和使用\"rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\"相同， 此时的DEST也是模块名称，不是路径。如：\n\n``` sh\nrsync -arv test rsync://ozone@crazyman.top/www\n```\n\n- rsync [OPTION]... [USER@]HOST:SRC [DEST]\n\n使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。SRC有两种写法：相对当前用户家目录的路径和绝对路径。当DEST省略时，只显示远程文件列表，不进行实际的拷贝工作。如:\n\n``` sh\nrsync -arv ozone@crazyman.top:temp test \nrsync -arv ozone@crazyman.top:/home/ozone/temp test \n```\n\n- rsync [OPTION]... [USER@]HOST::SRC [DEST]\n\n从远程rsync服务器中拷贝文件到本地机。SRC此时不再是路径，而是再服务器上rsync配置的模块名称。如：\n\n``` sh\nrsync -arv ozone@crazyman.top::www test\n```\n\n- rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n\n从远程rsync服务器中拷贝文件到本地机。和使用\"rsync [OPTION]... [USER@]HOST::SRC [DEST]\"相同， 此时的DEST也是模块名称，不是路径。如：\n\n``` sh\nrsync -arv rsync://ozone@crazyman.top/www test\n```\n\n几个需要注意的地方：\n\n- 从本地拷贝文件到远程计算机时，SRC可以指定多个\n- 当DEST为本地路径时，DEST参数可以省略，省略时只会显示文件列表，不执行实际的同步工作，这在确认远程路径内容时非常有用\n- 使用\":\"时，实际是通过remote shell连接，远程服务器不需要启动rsync服务。 使用\"::\"或\"rsync:\"时，连接到的是rysnc daemon, 所以这时要指定模块的名称\n\n### rsync 命令参数\n\nrsync参数很多，常用的参数如下：\n\n- -v, --verbose                 详细模式输出\n- -q, --quiet                   精简输出模式\n- -q, --no-motd                 不显示欢迎信息\n- -a, --archive                 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD\n- -a, --no-OPTION               关闭-a中打开的某个选项(e.g. --no-D)\n- -r, --recursive               对子目录以递归模式处理\n- -d, --dirs                    只拷贝文件夹\n- -R, --relative                使用相对路径信息\n- 更新\n    + -u, --update  跳过所有已经存在于DST，并且文件时间晚于要备份的文件\n    + -u, --inplace\n    + -u, --append\n    + -u, --append-verify\n\n- 文件备份\n    + -b, --backup                  创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。\n    + --backup-dir=DIR              将备份文件(如~filename)存放在在目录下。\n    + --suffix=SUFFIX               定义备份文件前缀\n\n- 链接处理\n    + -l, --links                   保留软链结\n    + -L, --copy-links              想对待常规文件一样处理软链结\n    + --copy-unsafe-links           仅仅拷贝指向SRC路径目录树以外的链结\n    + --safe-links                  忽略指向SRC路径目录树以外的链结\n    + -H, --hard-links              保留硬链结\n    + -k, --copy-dirlinks           把文件夹链接拷贝成一个链接文件\n    + -K, --keep-dirlinks           把文件夹链接拷贝成一个文件夹\n\n- 文件属性\n    + -A, --acls                    保持ACLs\n    + -X, --xattrs                  保持扩展属性\n    + -p, --perms                   保持文件权限\n    + -o, --owner                   保持文件属主信息\n    + -g, --group                   保持文件属组信息\n    + -D, --devices                 保持设备文件信息\n    + -t, --times                   保持文件时间信息\n\n- -S, --sparse                      对稀疏文件进行特殊处理以节省DST的空间\n- -n, --dry-run                     现实哪些文件将被传输\n- -W, --whole-file                  拷贝文件，不进行增量检测\n- -x, --one-file-system             不要跨越文件系统边界\n- -c, --checksum                    打开校验开关，强制对文件传输进行校验\n- -B, --block-size=SIZE             检验算法使用的块尺寸，默认是700字节\n\n- 文件排除\n    + -C, --cvs-exclude                 使用和CVS一样的方法自动忽略文件\n    + --exclude=PATTERN                 指定排除不需要传输的文件模式\n    + --include=PATTERN                 指定不排除而需要传输的文件模式\n    + --exclude-from=FILE               排除FILE中指定模式的文件\n    + --include-from=FILE               不排除FILE指定模式匹配的文件\n\n- --config=FILE                         指定其他的配置文件，不使用默认的rsyncd.conf文件\n- --password-file=FILE                  从FILE中得到密码\n- -z, --compress                        对备份的文件在传输时进行压缩处理\n- - --progress                            在传输时现实传输过程\n- --existing                            仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件\n- --delete                              删除那些DST中有SRC没有的文件\n--delete-excluded                       同样删除接收端那些被该选项指定排除的文件\n--delete-after                          传输结束以后再删除\n--ignore-errors                         及时出现IO错误也进行删除\n--partial                               保留那些因故没有完全传输的文件，以是加快随后的再次传输\n--force                                 强制删除目录，即使不为空","slug":"使用Rsync","published":1,"updated":"2015-05-07T11:03:06.000Z","_id":"ci9e26vsd0007f2ar4khxiewa","comments":1,"layout":"post","photos":[],"link":""},{"title":"Mac下添加定时任务","date":"2015-04-29T07:00:00.000Z","updated":"2015-05-04T05:01:09.000Z","layout":"post","comments":1,"_content":"\n## 步骤\n\n- 编写任务脚本\n\n把想要执行的工作写入脚本文件，如添加文件run.sh, 写入以下内容：\n\n```sh\n#!/bin/bash\necho `date` > $HOME/log\n```\n\n- 编写任务描述文件\n\nmac下的任务描述文件是plist格式的。结构如下：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">  \n<plist version=\"1.0\">  \n  <dict>\n    <!-- 名称，要全局唯一 -->\n    <key>Label</key>\n    <string>com.uniflor.notifier</string>\n\n    <!-- 要运行的程序， 如果省略这个选项，会把ProgramArguments的第一个\n    元素作为要运行的程序 -->\n    <key>Program</key>\n    <string>/Users/uniflor/script.sh</string>\n\n    <!-- 命令， 第一个为命令，其它为参数-->\n    <key>ProgramArguments</key>\n    <array>\n      <string>/Users/uniflor/script.sh</string>\n    </array>\n\n    <!-- 运行时间 -->\n    <key>StartCalendarInterval</key>\n    <dict>\n\n      <key>Minute</key>\n      <integer>30</integer>\n\n      <key>Hour</key>\n      <integer>9</integer>\n\n      <key>Day</key>\n      <integer>1</integer>\n\n      <key>Month</key>\n      <integer>5</integer>\n\n      <!-- 0和7都指星期天 -->\n      <key>Weekday</key>\n      <integer>0</integer>\n\n    </dict>\n\n    <!-- 运行间隔，与StartCalenderInterval使用其一，单位为秒 -->\n    <key>StartInterval</key>\n    <integer>30</integer>\n\n    <!-- 标准输入文件 -->\n    <key>StandardInPath</key>\n    <string>/Users/uniflor/run-in.log</string>\n\n    <!-- 标准输出文件 -->\n    <key>StandardOutPath</key>\n    <string>/Users/uniflor/Bin/run-out.log</string>\n\n    <!-- 标准错误输出文件 -->\n    <key>StandardErrorPath</key>\n    <string>/Users/uniflor/Bin/run-err.log</string>\n\n  </dict>  \n</plist>\n```\n\n\n两种指定要执行命令的方法：\n\n  + 使用Program和ProgramArguments\n\n    *Program*, 运行命令或要执行文件路径\n    *ProgramArguments*, 执行时传入参数\n\n  + 只使用ProgramArguments\n\n    此时，ProgramArguments的每个参数为要执行的命令或文件路径，其它参数为传入参数\n\n两种设置执行时间的方法：\n\n  + StartCalendarInterval\n\n    使用元素Minute, Hour, Day, Month, Weekday两指定执行时间，如：\n\n    ``` xml\n    <key>StartCalendarInterval</key>\n    <dict>\n      <key>Minute</key>\n      <integer>30</integer>\n      <key>Hour</key>\n      <integer>9</integer>\n    </dict>\n    ```\n\n  每天的9:30执行\n\n  + StartInterval\n  \n  设置执行的时间间隔，单位为秒\n\n  ``` xml\n  <key>StartInterval</key>\n  <integer>3600</integer>\n  ```\n\n  每小时执行一次\n\n- 使用launchctl加载plist\n\n  任务描述文件写好后，怎么使用它呢？可以使用launchctl工具，添加任务到launchd。\n\n  系统定义了几个位置来存放任务列表\n  + ~/Library/LaunchAgents         由用户自己定义的任务项\n  +  /Library/LaunchAgents         由管理员为用户定义的任务项\n  + /Library/LaunchDaemons         由管理员定义的守护进程任务项\n  + /System/Library/LaunchAgents   由Mac OS X为用户定义的任务项\n  + /System/Library/LaunchDaemons  由Mac OS X定义的守护进程任务项\n\n  *为用户定义的任务项，只以用户登陆后才会执行，守护进程任务项无论用户是否登陆都会执行*\n  根据添加的任务类型，把它拷贝到相应的目录，通过launchctl来加载：\n\n  + 添加 launchctl load /System/Library/LaunchAgents/com.test.plist\n  + 移除 launchctl unload /System/Library/LaunchAgents/com.test.plist\n  + 查看 launchctl list\n","source":"_posts/Mac下添加定时任务.md","raw":"title: \"Mac下添加定时任务\"\ndate: 2015-04-29 15:00:00\nupdated:\nlayout: post\ncomments: true\ncategories:\n- 系统\n- Mac\ntags:\n---\n\n## 步骤\n\n- 编写任务脚本\n\n把想要执行的工作写入脚本文件，如添加文件run.sh, 写入以下内容：\n\n```sh\n#!/bin/bash\necho `date` > $HOME/log\n```\n\n- 编写任务描述文件\n\nmac下的任务描述文件是plist格式的。结构如下：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">  \n<plist version=\"1.0\">  \n  <dict>\n    <!-- 名称，要全局唯一 -->\n    <key>Label</key>\n    <string>com.uniflor.notifier</string>\n\n    <!-- 要运行的程序， 如果省略这个选项，会把ProgramArguments的第一个\n    元素作为要运行的程序 -->\n    <key>Program</key>\n    <string>/Users/uniflor/script.sh</string>\n\n    <!-- 命令， 第一个为命令，其它为参数-->\n    <key>ProgramArguments</key>\n    <array>\n      <string>/Users/uniflor/script.sh</string>\n    </array>\n\n    <!-- 运行时间 -->\n    <key>StartCalendarInterval</key>\n    <dict>\n\n      <key>Minute</key>\n      <integer>30</integer>\n\n      <key>Hour</key>\n      <integer>9</integer>\n\n      <key>Day</key>\n      <integer>1</integer>\n\n      <key>Month</key>\n      <integer>5</integer>\n\n      <!-- 0和7都指星期天 -->\n      <key>Weekday</key>\n      <integer>0</integer>\n\n    </dict>\n\n    <!-- 运行间隔，与StartCalenderInterval使用其一，单位为秒 -->\n    <key>StartInterval</key>\n    <integer>30</integer>\n\n    <!-- 标准输入文件 -->\n    <key>StandardInPath</key>\n    <string>/Users/uniflor/run-in.log</string>\n\n    <!-- 标准输出文件 -->\n    <key>StandardOutPath</key>\n    <string>/Users/uniflor/Bin/run-out.log</string>\n\n    <!-- 标准错误输出文件 -->\n    <key>StandardErrorPath</key>\n    <string>/Users/uniflor/Bin/run-err.log</string>\n\n  </dict>  \n</plist>\n```\n\n\n两种指定要执行命令的方法：\n\n  + 使用Program和ProgramArguments\n\n    *Program*, 运行命令或要执行文件路径\n    *ProgramArguments*, 执行时传入参数\n\n  + 只使用ProgramArguments\n\n    此时，ProgramArguments的每个参数为要执行的命令或文件路径，其它参数为传入参数\n\n两种设置执行时间的方法：\n\n  + StartCalendarInterval\n\n    使用元素Minute, Hour, Day, Month, Weekday两指定执行时间，如：\n\n    ``` xml\n    <key>StartCalendarInterval</key>\n    <dict>\n      <key>Minute</key>\n      <integer>30</integer>\n      <key>Hour</key>\n      <integer>9</integer>\n    </dict>\n    ```\n\n  每天的9:30执行\n\n  + StartInterval\n  \n  设置执行的时间间隔，单位为秒\n\n  ``` xml\n  <key>StartInterval</key>\n  <integer>3600</integer>\n  ```\n\n  每小时执行一次\n\n- 使用launchctl加载plist\n\n  任务描述文件写好后，怎么使用它呢？可以使用launchctl工具，添加任务到launchd。\n\n  系统定义了几个位置来存放任务列表\n  + ~/Library/LaunchAgents         由用户自己定义的任务项\n  +  /Library/LaunchAgents         由管理员为用户定义的任务项\n  + /Library/LaunchDaemons         由管理员定义的守护进程任务项\n  + /System/Library/LaunchAgents   由Mac OS X为用户定义的任务项\n  + /System/Library/LaunchDaemons  由Mac OS X定义的守护进程任务项\n\n  *为用户定义的任务项，只以用户登陆后才会执行，守护进程任务项无论用户是否登陆都会执行*\n  根据添加的任务类型，把它拷贝到相应的目录，通过launchctl来加载：\n\n  + 添加 launchctl load /System/Library/LaunchAgents/com.test.plist\n  + 移除 launchctl unload /System/Library/LaunchAgents/com.test.plist\n  + 查看 launchctl list\n","slug":"Mac下添加定时任务","published":1,"photos":[],"link":"","_id":"ci9e26vsl000cf2aru0vqtkid"},{"title":"Lua教程三","date":"2015-05-04T14:46:09.000Z","layout":"post","comments":1,"_content":"\n## 面向对象\n\n*lua中本是没有对象这个东西的。但由于lua中有table这一强大的数据结构，\n我们可以通过table来实现面向对象的结构*\n\n``` lua\nuser = {name = \"max\", type = \"admin\", hi = function(user)\n    print(\"Hello, I am \" .. user.name)\nend}\n\n-- 获取属性\nlocal type = user.type\n\n-- 调用方法\nuser.hi(user)\n```\n\n*这种结构看起来比较怪异，不符合我们一般对面向对象中类的认识，可以改进以下结构*\n\n``` lua\nUser = {}\n\nUser.type = \"admin\"\n\nfunction User.new(name)\n    User.name = name\n    return User\nend\n\nfunction User.hi()\n    print(\"Hi, I am \" .. User.name)\nend\n\nlocal user1 = User.new(\"max\")\nuser1.hi()\n```\n\n*这种结构起来要正常多了，但会有一个问题，在这段代码下再加几行*\n\n``` lua\nlocal user2 = User.new(\"xxx\")\nuser2.hi() -- 输出 \"Hi, I am xxx\"\nuser1.hi() -- 输出 \"Hi, I am xxx\"\n```\n\n*创建新的实例user2后，表User的name被修改了，而user1引用的还是User，所以出错了。为了解决这个问题，再次改进一下结构*\n\n``` lua\nUser = {}\nUser.type = \"admin\"\n\nfunction User.new(self, name)\n    instance = {}\n    instance.name = name\n    -- 这里self指向的是表User, 表insance以User为模板\n    setmetatable(instance, self)\n    self.__index = self\n    return instance\nend\nfunction User.hi(self)\n    print(\"Hi, I am \" .. self.name)\nend\n\nlocal user1 = User.new(User, \"max\")\nuser1:hi(user1)\n\nlocal user2 = User.new(User, \"xxx\")\nuser2.hi(user2)\n\nuser1.hi(user1)\n```\n\n*现在结构清晰多了，而且创建的实例之间也不会互相影响了，但是这种结构需要在调用类的方法时把自己当成第一个参数传递给方法，写起来有些麻烦，所有lua中引入了新的操作符号\":\"。通过\":\"调用方法时会默认添加一个参数self, 指向调用者。对以下代码再次改进：*\n\n``` lua\nUser = {}\nUser.type = \"admin\"\n\nfunction User:new(name)\n    instance = {}\n    instance.name = name\n    setmetatable(instance, self)\n    self.__index = self\n    return instance\nend\nfunction User:hi()\n    print(\"Hi, I am \" .. self.name)\nend\n\nlocal user1 = User:new(\"max\")\nuser1:hi()\n\nlocal user2 = User:new(\"xxx\")\nuser2:hi()\n\nuser1:hi()\n```\n    \n\n\n","source":"_posts/Lua教程3.md","raw":"title: \"Lua教程三\"\ndate: 2015-05-04 22:46:09\nlayout: post\ncomments: true\ncategories:\n- 语言\n- LUA\n---\n\n## 面向对象\n\n*lua中本是没有对象这个东西的。但由于lua中有table这一强大的数据结构，\n我们可以通过table来实现面向对象的结构*\n\n``` lua\nuser = {name = \"max\", type = \"admin\", hi = function(user)\n    print(\"Hello, I am \" .. user.name)\nend}\n\n-- 获取属性\nlocal type = user.type\n\n-- 调用方法\nuser.hi(user)\n```\n\n*这种结构看起来比较怪异，不符合我们一般对面向对象中类的认识，可以改进以下结构*\n\n``` lua\nUser = {}\n\nUser.type = \"admin\"\n\nfunction User.new(name)\n    User.name = name\n    return User\nend\n\nfunction User.hi()\n    print(\"Hi, I am \" .. User.name)\nend\n\nlocal user1 = User.new(\"max\")\nuser1.hi()\n```\n\n*这种结构起来要正常多了，但会有一个问题，在这段代码下再加几行*\n\n``` lua\nlocal user2 = User.new(\"xxx\")\nuser2.hi() -- 输出 \"Hi, I am xxx\"\nuser1.hi() -- 输出 \"Hi, I am xxx\"\n```\n\n*创建新的实例user2后，表User的name被修改了，而user1引用的还是User，所以出错了。为了解决这个问题，再次改进一下结构*\n\n``` lua\nUser = {}\nUser.type = \"admin\"\n\nfunction User.new(self, name)\n    instance = {}\n    instance.name = name\n    -- 这里self指向的是表User, 表insance以User为模板\n    setmetatable(instance, self)\n    self.__index = self\n    return instance\nend\nfunction User.hi(self)\n    print(\"Hi, I am \" .. self.name)\nend\n\nlocal user1 = User.new(User, \"max\")\nuser1:hi(user1)\n\nlocal user2 = User.new(User, \"xxx\")\nuser2.hi(user2)\n\nuser1.hi(user1)\n```\n\n*现在结构清晰多了，而且创建的实例之间也不会互相影响了，但是这种结构需要在调用类的方法时把自己当成第一个参数传递给方法，写起来有些麻烦，所有lua中引入了新的操作符号\":\"。通过\":\"调用方法时会默认添加一个参数self, 指向调用者。对以下代码再次改进：*\n\n``` lua\nUser = {}\nUser.type = \"admin\"\n\nfunction User:new(name)\n    instance = {}\n    instance.name = name\n    setmetatable(instance, self)\n    self.__index = self\n    return instance\nend\nfunction User:hi()\n    print(\"Hi, I am \" .. self.name)\nend\n\nlocal user1 = User:new(\"max\")\nuser1:hi()\n\nlocal user2 = User:new(\"xxx\")\nuser2:hi()\n\nuser1:hi()\n```\n    \n\n\n","slug":"Lua教程3","published":1,"updated":"2015-05-05T04:41:40.000Z","photos":[],"link":"","_id":"ci9e26wje000gf2argn2pglr9"},{"title":"Lua教程二","date":"2015-05-04T14:39:09.000Z","layout":"post","comments":1,"_content":"\n## 常用内置方法\n\n- type 判断数据类型\n\n    *type(arg)*\n    接收一个参数， 返回值为string类型\n\n    ``` lua\n    local a = 1\n    local b = \"1\"\n    local c = true\n\n    print(type(a), type(b), type(c))\n    ```\n\n    *返回值为八种数据类型其中之一：\"nil\", \"number\", \"string\", \"boolean\", \"table\", \"function\", \"thread\", and \"userdata\"。*\n\n    *注意返回的值都是字符串*\n\n- print 打印信息\n\n    *print(arg1, arg2, ...)*\n    *可以接收任意个数的参数，不支持格式化输出，要格式化输出，使用string.format()转化后输出*\n\n    ``` lua\n    local a = \"Hello\"\n    local b = \"Lua\"\n    print(a, b)\n    print(a .. \",\" .. b)\n    ```\n\n- tostring 转换成字符串类型\n\n    *tostring(arg)*\n    \n- tonumber 转换成数值类型\n\n    *tonumber(arg)*\n\n- assert 断言\n\n    *assert(v, msg)*\n    *v为要判断的值，当v的值为false时， 打印错误，错误的描述为msg字符串*\n    *当v的值为false时，打印错误，程序会终止运行*\n\n    ``` lua\n    local i = 0\n    assert(i > 0, \"can not run, i <= 0\")\n    ```\n\n- pcall 在安全模式下调用方法\n\n    *pcall(func, arg1, arg2, ...)*\n    *可以通过pcall(func)以安全模式调用方法，方法func执行成功，pcall返回true, func执行失败，返回false和一个错误描述*\n\n    ``` lua\n    function check()\n        local id = 12\n        assert(id > 10, \"id can not less then 10\")\n    end\n\n    local status, message = pcall(check)\n    if not status then\n        print(message)\n    else\n        print(\"success\")\n    end\n    ```\n\n- xpcall 与pcall相似\n\n    *xpcall(func, fh, arg1, arg2, ...)*\n    *可以指定一个异常处理方法fh, 返回结果与pcall相同* \n\n- loadfile 加载外部lua文件\n    \n    *loadfile(filename)*\n    *加载一个外部的lua文件， 返回一个function*\n\n    ``` lua\n    local runInit = loadfile(\"init.lua\")\n    runInit()\n    ```\n\n- dofile 执行外部lua文件\n\n    *dofile(filename)*\n    *加载一个外部的lua文件，并执行其中的语句, 返回值为外部lua文件的返回值*\n\n    ``` lua\n    local result = dofile(\"init.lua\")\n    ```\n\n- require 加载外部模块\n\n    *require(modname)*\n    *加载外部外部模块， 返回值为模块的返回值，具体加载过程参考package库部分*\n\n    ``` lua\n    local user = require(\"user\")\n    user.hello()\n    ```\n\n## 全局变量\n\n*_G*\n    \n*lua语言内部全局变量，类型为table, 系统内置方法、加载的库、全局变量都存在这里*\n\n``` lua\nxxxx = {1, 2, 3}\nfor k,v in pairs(_G) do\n    print(k,v)\nend\n```\n\n## 内置库（模块）\n\n- package\n    \n    *管理通过require加载的模块*\n    *当通过require加载模块时，按一下列过程查找模块*\n\n    + 检查package.loaded, 若package.loaded[modname]不为nil,则返回 package.loaded[modname]的值\n    + 若没有加载过，则通过以下四步查找模块\n        - 查找package.preload里是否有对应的模块，有则返回，没有进入下一步\n        - 根据package.path中的设置路径，拼合上模块的名称后，依次进行查找，找到后进行加载，找不到进入下一步\n        - 与上一步相似，从package.cpath的路径中查找\n        - 查找c库\n    \n    *package.path， package.cpath,决定了加载模块时的查找路径，可以通过修改它们的值来添加模块加载路径*\n\n    ``` lua\n    package.path = string.format(\"%s;%s\", package.path, \"./mods/?.lua\")\n\n    print(package.path)\n    ```\n\n    *package.loaded保存了已经加载的模块， 当通过require加载模块成功后，模块会自动添加进package.loaded中*\n\n- table\n\n    *table模块提供了对table的基本操作方法*\n\n    + table.insert (list, [pos,] value)\n        *向list中插入元素*\n        *pos为要插入的位置，插入后pos之后的元素索引自动调整， 省略时，元素插入到list的末尾*\n\n        ``` lua\n        local t = {2, 4, 6, 8}\n        table.insert(t, 10)\n        table.insert(t, 3, 12)\n        for i,v in ipairs(t) do\n            print(i,v)\n        end\n        ```\n\n    + table.remove (list [, pos])\n        *移除list中的元素*\n        *pos为要移除元素的位置，取值1到#list, 移除后pos之后元素的索引自动调整，省略时移除末尾的元素*\n        \n        ``` lua\n        local t = {2, 4, 6, 8}\n        table.remove(t, 3)\n        for i, k in pairs(t) do\n            print(i, k)\n        end\n        ```\n\n    + table.move (a1, f, e, t [,a2])\n        *移动table中的元素*\n        *a1为源table, a2为目的table, a2省略时，a1同时为目的table*\n        *f和e为源table中要移动的元素的起始和终止位置， t为为目的table中的起始位置*\n\n        ``` lua\n        local x = {\"a\", \"b\", \"c\", \"d\"}\n        local y = {\"e\", \"f\", \"g\", \"h\"}\n\n        -- 移动x中的第1，2个元素到第4个位置\n        -- 移动后x中元素为a,b,c,a,b， 原来位置的元素被覆盖，长度也增加了\n        table.move(x, 1, 2, 4)\n        for i,v in pairs(x) do\n            print(i,v)\n        end\n\n        -- 移动x中的b, c 到y的1，2位置\n        -- 移动后y中的元素为b,c,g,h\n        table.move(x, 2, 3, 1, y)\n        for i,v in pairs(y) do\n            print(i,v)\n        end\n        ```\n\n    + table.concat (list [, sep [, i [, j]]])\n        *连接list中的元素*\n        *sep为连接字符串， i为起始位置， j为终止位置*\n\n        ``` lua\n        local t3 = {2, 4, 6, 8}\n        print(table.concat(t3, \"-\"))\n        print(table.concat(t3, \"--\", 2, 4))\n        ```\n\n    + table.sort (list [, comp])\n        *对table的元素进行排序*\n        *comp为排序函数，该函数接收两个参数，但函数返回值为true不交换传入的两个参数的位置，返回值为false则交换两个参数的位置*\n        *comp省略时，默认使用以下排序函数：*\n        ``` lua\n        function(x, y)\n            return x < y\n        end\n        ```\n\n        ``` lua\n        local t = {34, 29, 88, 99, 123}\n        table.sort(t, function(a, b)\n            return a > b\n        end)\n        for i,v in ipairs(t7) do\n            print(i,v)\n        end\n        ```\n\n    + table.pack (···)\n        *把传入的参数打包成一个table，并加入一个元素\"n\", 值为打包进table的元素个数*\n\n        ``` lua\n        local a = 123\n        local b = 234\n        local c = 345\n        local t = table.pack(a, b, c)\n        for k,v in pairs(t) do\n            print(k,v)\n        end\n        ```\n\n    + table.unpack (list [, i [, j]])\n        *把table 拆开, 只会返回数字索引元素的值*\n        *i为起始元素的索引，j为终止元素的索引*\n\n        ``` lua\n        local t = {1, 2, 3, s = 4, 5}\n        local x, y, z, n = table.unpack(t)\n        print(x, y, z, n)\n        ```\n\n- string\n\n    *对字符串进行处理*\n\n    + string.byte(s, i, j)\n    + string.char(...)\n    + string.find (s, pattern [, init [, plain]])\n    + string.dump (function [, strip])\n    + string.format(format, ...)\n    + string.gmatch (s, pattern)\n    + string.gsub (s, pattern, repl [, n])\n    + string.len (s)\n    + string.lower (s)\n    + string.match (s, pattern [, init])\n    + string.pack (fmt, v1, v2, ···)\n    + string.packsize (fmt)\n    + string.rep (s, n [, sep])\n    + string.reverse (s)\n    + string.sub (s, i [, j])\n    + string.unpack (fmt, s [, pos])\n    + string.upper (s)\n\n\n- math\n\n    *数学常用函数库*\n\n    + math.abs (x)\n\n    + math.acos (x)\n\n    + math.asin (x)\n\n    + math.atan (y [, x])\n\n    + math.ceil (x)\n\n    + math.cos (x)\n\n    + math.deg (x)\n\n    + math.exp (x)\n\n    + math.floor (x)\n\n    + math.fmod (x, y)\n\n    + math.log (x [, base])\n\n    + math.max (x, ···)\n\n    + math.min (x, ···)\n\n    + math.modf (x)\n\n    + math.rad (x)\n\n    + math.random ([m [, n]])\n\n    + math.randomseed (x)\n\n    + math.sin (x)\n\n    + math.sqrt (x)\n\n    + math.tan (x)\n\n    + math.tointeger (x)\n\n    + math.type (x)\n\n    + math.ult (m, n)\n\n- io\n\n    *io库提供对标准输入输出以及文件的基本操作*\n\n    + io.close ([file]) 关闭打开的文件，省略参数时，关闭当前默认的输出文件\n\n    + io.flush () 把对文件进行的改动写到文件中， 等同于io.output():flush()\n\n    + io.input ([file]) 设置文件为默认的输入文件，省略参数时设置，返回当前默认的输入文件\n\n    + io.lines ([filename ···]) 打开文件并返回一个行遍历器\n    \n    + io.open (filename [, mode]) 以指定的模式打开一个文件，返回文件句柄\n    \n        *打开方式：*\n\n        - \"r\": 只读（默认）\n        - \"w\": 只写\n        - \"a\": 追加\n        - \"r+\": 更新，先前的内容保留\n        - \"w+\": 更新，先前的内容清空\n        - \"a+\": 从末尾添加\n\n    + io.output ([file]) 设置文件为默认的输出文件，省略参数时设置，返回当前默认的输出文件\n\n    + io.popen (prog [, mode]) 在新的进程中打开文件， 不是在所有的平台上可用\n\n    + io.read (···) 读取文件的内容\n\n    + io.tmpfile () 创建一个堆里零时文件，返回这个文件的句柄，程序结束后会自动删除这个文件\n\n    + io.type (obj) 检测obj是否是一个打开的文件句柄，返回值为\"file\", \"closed file\", nil\n\n    + io.write (···) 向当前输出文件写入内容\n\n- os\n\n    *封装了一些秕方法*\n\n    + os.clock () 返回CPU时间的近似值\n\n    + os.date ([format [, time]]) 返回系统日期\n\n        *返回两种形式的结果， 参数字符串为'*t'时，返回table, 参数为格式化字符串时，返回日期的字符串*\n        *格式化参数*\n\n        - %a 星期几的简写\n        - %A 星期几的全称\n        - %b 月份的简写\n        - %B 月份的全称\n        - %c 标准的日期的时间串\n        - %C 年份的前两位数字\n        - %d 十进制表示的每月的第几天\n        - %D 月/天/年\n        - %e 在两字符域中，十进制表示的每月的第几天\n        - %F 年-月-日\n        - %g 年份的后两位数字，使用基于周的年\n        - %G 年份，使用基于周的年\n        - %h 简写的月份名\n        - %H 24小时制的小时\n        - %I 12小时制的小时\n        - %j 十进制表示的每年的第几天\n        - %m 十进制表示的月份\n        - %M 十时制表示的分钟数\n        - %n 新行符\n        - %p 本地的AM或PM的等价显示\n        - %r 12小时的时间\n        - %R 显示小时和分钟：hh:mm\n        - %S 十进制的秒数\n        - %t 水平制表符\n        - %T 显示时分秒：hh:mm:ss\n        - %u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）\n        - %U 第年的第几周，把星期日作为第一天（值从0到53）\n        - %V 每年的第几周，使用基于周的年\n        - %w 十进制表示的星期几（值从0到6，星期天为0）\n        - %W 每年的第几周，把星期一做为第一天（值从0到53）\n        - %x 标准的日期串\n        - %X 标准的时间串\n        - %y 不带世纪的十进制年份（值从0到99）\n        - %Y 带世纪部分的十制年份\n        - %z，%Z 时区名称，如果不能得到时区名称则返回空字符。\n        - %% 百分号\n\n    ``` lua\n    print(os.date(\"%D\"))\n    print(os.data())\n    ```\n\n    + os.time ([table])返回时间值\n\n        *不带参数时返回当前时间值，有参数时把传入的时间转为时间值*\n\n        ``` lua\n        print(os.time())\n        print(os.time({year = 2015, month = 3, day = 19, hour = 12, min = 0, sec = 0}))\n        ```\n\n    + os.difftime (t2, t1) 返回时间差，单位为秒（t2-t1)\n\n    + os.execute ([command]) 执行系统命令\n\n    + os.exit ([code [, close]]) 终止宿主程序\n\n    + os.getenv (varname) 返回当前程序的环境变量\n\n    + os.remove (filename) 删除文件\n\n    + os.rename (oldname, newname) 文件重命名\n\n    + os.setlocale (locale [, category]) 设置程序的当前设置\n\n    + os.tmpname () 返回一个零时文件名，在unix-like系统上，会创建相应的文件\n\n- utf8\n\n    *提供对utf8编码的支持*\n\n- debug\n\n    *提供一些与调试相关的方法*\n\n\n\n","source":"_posts/Lua教程2.md","raw":"title: \"Lua教程二\"\ndate: 2015-05-04 22:39:09\nlayout: post\ncomments: true\ncategories:\n- 语言\n- LUA\n---\n\n## 常用内置方法\n\n- type 判断数据类型\n\n    *type(arg)*\n    接收一个参数， 返回值为string类型\n\n    ``` lua\n    local a = 1\n    local b = \"1\"\n    local c = true\n\n    print(type(a), type(b), type(c))\n    ```\n\n    *返回值为八种数据类型其中之一：\"nil\", \"number\", \"string\", \"boolean\", \"table\", \"function\", \"thread\", and \"userdata\"。*\n\n    *注意返回的值都是字符串*\n\n- print 打印信息\n\n    *print(arg1, arg2, ...)*\n    *可以接收任意个数的参数，不支持格式化输出，要格式化输出，使用string.format()转化后输出*\n\n    ``` lua\n    local a = \"Hello\"\n    local b = \"Lua\"\n    print(a, b)\n    print(a .. \",\" .. b)\n    ```\n\n- tostring 转换成字符串类型\n\n    *tostring(arg)*\n    \n- tonumber 转换成数值类型\n\n    *tonumber(arg)*\n\n- assert 断言\n\n    *assert(v, msg)*\n    *v为要判断的值，当v的值为false时， 打印错误，错误的描述为msg字符串*\n    *当v的值为false时，打印错误，程序会终止运行*\n\n    ``` lua\n    local i = 0\n    assert(i > 0, \"can not run, i <= 0\")\n    ```\n\n- pcall 在安全模式下调用方法\n\n    *pcall(func, arg1, arg2, ...)*\n    *可以通过pcall(func)以安全模式调用方法，方法func执行成功，pcall返回true, func执行失败，返回false和一个错误描述*\n\n    ``` lua\n    function check()\n        local id = 12\n        assert(id > 10, \"id can not less then 10\")\n    end\n\n    local status, message = pcall(check)\n    if not status then\n        print(message)\n    else\n        print(\"success\")\n    end\n    ```\n\n- xpcall 与pcall相似\n\n    *xpcall(func, fh, arg1, arg2, ...)*\n    *可以指定一个异常处理方法fh, 返回结果与pcall相同* \n\n- loadfile 加载外部lua文件\n    \n    *loadfile(filename)*\n    *加载一个外部的lua文件， 返回一个function*\n\n    ``` lua\n    local runInit = loadfile(\"init.lua\")\n    runInit()\n    ```\n\n- dofile 执行外部lua文件\n\n    *dofile(filename)*\n    *加载一个外部的lua文件，并执行其中的语句, 返回值为外部lua文件的返回值*\n\n    ``` lua\n    local result = dofile(\"init.lua\")\n    ```\n\n- require 加载外部模块\n\n    *require(modname)*\n    *加载外部外部模块， 返回值为模块的返回值，具体加载过程参考package库部分*\n\n    ``` lua\n    local user = require(\"user\")\n    user.hello()\n    ```\n\n## 全局变量\n\n*_G*\n    \n*lua语言内部全局变量，类型为table, 系统内置方法、加载的库、全局变量都存在这里*\n\n``` lua\nxxxx = {1, 2, 3}\nfor k,v in pairs(_G) do\n    print(k,v)\nend\n```\n\n## 内置库（模块）\n\n- package\n    \n    *管理通过require加载的模块*\n    *当通过require加载模块时，按一下列过程查找模块*\n\n    + 检查package.loaded, 若package.loaded[modname]不为nil,则返回 package.loaded[modname]的值\n    + 若没有加载过，则通过以下四步查找模块\n        - 查找package.preload里是否有对应的模块，有则返回，没有进入下一步\n        - 根据package.path中的设置路径，拼合上模块的名称后，依次进行查找，找到后进行加载，找不到进入下一步\n        - 与上一步相似，从package.cpath的路径中查找\n        - 查找c库\n    \n    *package.path， package.cpath,决定了加载模块时的查找路径，可以通过修改它们的值来添加模块加载路径*\n\n    ``` lua\n    package.path = string.format(\"%s;%s\", package.path, \"./mods/?.lua\")\n\n    print(package.path)\n    ```\n\n    *package.loaded保存了已经加载的模块， 当通过require加载模块成功后，模块会自动添加进package.loaded中*\n\n- table\n\n    *table模块提供了对table的基本操作方法*\n\n    + table.insert (list, [pos,] value)\n        *向list中插入元素*\n        *pos为要插入的位置，插入后pos之后的元素索引自动调整， 省略时，元素插入到list的末尾*\n\n        ``` lua\n        local t = {2, 4, 6, 8}\n        table.insert(t, 10)\n        table.insert(t, 3, 12)\n        for i,v in ipairs(t) do\n            print(i,v)\n        end\n        ```\n\n    + table.remove (list [, pos])\n        *移除list中的元素*\n        *pos为要移除元素的位置，取值1到#list, 移除后pos之后元素的索引自动调整，省略时移除末尾的元素*\n        \n        ``` lua\n        local t = {2, 4, 6, 8}\n        table.remove(t, 3)\n        for i, k in pairs(t) do\n            print(i, k)\n        end\n        ```\n\n    + table.move (a1, f, e, t [,a2])\n        *移动table中的元素*\n        *a1为源table, a2为目的table, a2省略时，a1同时为目的table*\n        *f和e为源table中要移动的元素的起始和终止位置， t为为目的table中的起始位置*\n\n        ``` lua\n        local x = {\"a\", \"b\", \"c\", \"d\"}\n        local y = {\"e\", \"f\", \"g\", \"h\"}\n\n        -- 移动x中的第1，2个元素到第4个位置\n        -- 移动后x中元素为a,b,c,a,b， 原来位置的元素被覆盖，长度也增加了\n        table.move(x, 1, 2, 4)\n        for i,v in pairs(x) do\n            print(i,v)\n        end\n\n        -- 移动x中的b, c 到y的1，2位置\n        -- 移动后y中的元素为b,c,g,h\n        table.move(x, 2, 3, 1, y)\n        for i,v in pairs(y) do\n            print(i,v)\n        end\n        ```\n\n    + table.concat (list [, sep [, i [, j]]])\n        *连接list中的元素*\n        *sep为连接字符串， i为起始位置， j为终止位置*\n\n        ``` lua\n        local t3 = {2, 4, 6, 8}\n        print(table.concat(t3, \"-\"))\n        print(table.concat(t3, \"--\", 2, 4))\n        ```\n\n    + table.sort (list [, comp])\n        *对table的元素进行排序*\n        *comp为排序函数，该函数接收两个参数，但函数返回值为true不交换传入的两个参数的位置，返回值为false则交换两个参数的位置*\n        *comp省略时，默认使用以下排序函数：*\n        ``` lua\n        function(x, y)\n            return x < y\n        end\n        ```\n\n        ``` lua\n        local t = {34, 29, 88, 99, 123}\n        table.sort(t, function(a, b)\n            return a > b\n        end)\n        for i,v in ipairs(t7) do\n            print(i,v)\n        end\n        ```\n\n    + table.pack (···)\n        *把传入的参数打包成一个table，并加入一个元素\"n\", 值为打包进table的元素个数*\n\n        ``` lua\n        local a = 123\n        local b = 234\n        local c = 345\n        local t = table.pack(a, b, c)\n        for k,v in pairs(t) do\n            print(k,v)\n        end\n        ```\n\n    + table.unpack (list [, i [, j]])\n        *把table 拆开, 只会返回数字索引元素的值*\n        *i为起始元素的索引，j为终止元素的索引*\n\n        ``` lua\n        local t = {1, 2, 3, s = 4, 5}\n        local x, y, z, n = table.unpack(t)\n        print(x, y, z, n)\n        ```\n\n- string\n\n    *对字符串进行处理*\n\n    + string.byte(s, i, j)\n    + string.char(...)\n    + string.find (s, pattern [, init [, plain]])\n    + string.dump (function [, strip])\n    + string.format(format, ...)\n    + string.gmatch (s, pattern)\n    + string.gsub (s, pattern, repl [, n])\n    + string.len (s)\n    + string.lower (s)\n    + string.match (s, pattern [, init])\n    + string.pack (fmt, v1, v2, ···)\n    + string.packsize (fmt)\n    + string.rep (s, n [, sep])\n    + string.reverse (s)\n    + string.sub (s, i [, j])\n    + string.unpack (fmt, s [, pos])\n    + string.upper (s)\n\n\n- math\n\n    *数学常用函数库*\n\n    + math.abs (x)\n\n    + math.acos (x)\n\n    + math.asin (x)\n\n    + math.atan (y [, x])\n\n    + math.ceil (x)\n\n    + math.cos (x)\n\n    + math.deg (x)\n\n    + math.exp (x)\n\n    + math.floor (x)\n\n    + math.fmod (x, y)\n\n    + math.log (x [, base])\n\n    + math.max (x, ···)\n\n    + math.min (x, ···)\n\n    + math.modf (x)\n\n    + math.rad (x)\n\n    + math.random ([m [, n]])\n\n    + math.randomseed (x)\n\n    + math.sin (x)\n\n    + math.sqrt (x)\n\n    + math.tan (x)\n\n    + math.tointeger (x)\n\n    + math.type (x)\n\n    + math.ult (m, n)\n\n- io\n\n    *io库提供对标准输入输出以及文件的基本操作*\n\n    + io.close ([file]) 关闭打开的文件，省略参数时，关闭当前默认的输出文件\n\n    + io.flush () 把对文件进行的改动写到文件中， 等同于io.output():flush()\n\n    + io.input ([file]) 设置文件为默认的输入文件，省略参数时设置，返回当前默认的输入文件\n\n    + io.lines ([filename ···]) 打开文件并返回一个行遍历器\n    \n    + io.open (filename [, mode]) 以指定的模式打开一个文件，返回文件句柄\n    \n        *打开方式：*\n\n        - \"r\": 只读（默认）\n        - \"w\": 只写\n        - \"a\": 追加\n        - \"r+\": 更新，先前的内容保留\n        - \"w+\": 更新，先前的内容清空\n        - \"a+\": 从末尾添加\n\n    + io.output ([file]) 设置文件为默认的输出文件，省略参数时设置，返回当前默认的输出文件\n\n    + io.popen (prog [, mode]) 在新的进程中打开文件， 不是在所有的平台上可用\n\n    + io.read (···) 读取文件的内容\n\n    + io.tmpfile () 创建一个堆里零时文件，返回这个文件的句柄，程序结束后会自动删除这个文件\n\n    + io.type (obj) 检测obj是否是一个打开的文件句柄，返回值为\"file\", \"closed file\", nil\n\n    + io.write (···) 向当前输出文件写入内容\n\n- os\n\n    *封装了一些秕方法*\n\n    + os.clock () 返回CPU时间的近似值\n\n    + os.date ([format [, time]]) 返回系统日期\n\n        *返回两种形式的结果， 参数字符串为'*t'时，返回table, 参数为格式化字符串时，返回日期的字符串*\n        *格式化参数*\n\n        - %a 星期几的简写\n        - %A 星期几的全称\n        - %b 月份的简写\n        - %B 月份的全称\n        - %c 标准的日期的时间串\n        - %C 年份的前两位数字\n        - %d 十进制表示的每月的第几天\n        - %D 月/天/年\n        - %e 在两字符域中，十进制表示的每月的第几天\n        - %F 年-月-日\n        - %g 年份的后两位数字，使用基于周的年\n        - %G 年份，使用基于周的年\n        - %h 简写的月份名\n        - %H 24小时制的小时\n        - %I 12小时制的小时\n        - %j 十进制表示的每年的第几天\n        - %m 十进制表示的月份\n        - %M 十时制表示的分钟数\n        - %n 新行符\n        - %p 本地的AM或PM的等价显示\n        - %r 12小时的时间\n        - %R 显示小时和分钟：hh:mm\n        - %S 十进制的秒数\n        - %t 水平制表符\n        - %T 显示时分秒：hh:mm:ss\n        - %u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）\n        - %U 第年的第几周，把星期日作为第一天（值从0到53）\n        - %V 每年的第几周，使用基于周的年\n        - %w 十进制表示的星期几（值从0到6，星期天为0）\n        - %W 每年的第几周，把星期一做为第一天（值从0到53）\n        - %x 标准的日期串\n        - %X 标准的时间串\n        - %y 不带世纪的十进制年份（值从0到99）\n        - %Y 带世纪部分的十制年份\n        - %z，%Z 时区名称，如果不能得到时区名称则返回空字符。\n        - %% 百分号\n\n    ``` lua\n    print(os.date(\"%D\"))\n    print(os.data())\n    ```\n\n    + os.time ([table])返回时间值\n\n        *不带参数时返回当前时间值，有参数时把传入的时间转为时间值*\n\n        ``` lua\n        print(os.time())\n        print(os.time({year = 2015, month = 3, day = 19, hour = 12, min = 0, sec = 0}))\n        ```\n\n    + os.difftime (t2, t1) 返回时间差，单位为秒（t2-t1)\n\n    + os.execute ([command]) 执行系统命令\n\n    + os.exit ([code [, close]]) 终止宿主程序\n\n    + os.getenv (varname) 返回当前程序的环境变量\n\n    + os.remove (filename) 删除文件\n\n    + os.rename (oldname, newname) 文件重命名\n\n    + os.setlocale (locale [, category]) 设置程序的当前设置\n\n    + os.tmpname () 返回一个零时文件名，在unix-like系统上，会创建相应的文件\n\n- utf8\n\n    *提供对utf8编码的支持*\n\n- debug\n\n    *提供一些与调试相关的方法*\n\n\n\n","slug":"Lua教程2","published":1,"updated":"2015-05-05T04:41:40.000Z","photos":[],"link":"","_id":"ci9e26wr4000lf2ar9gnl6jy6"},{"title":"Lua教程一","date":"2015-05-04T14:38:09.000Z","layout":"post","comments":1,"_content":"\n## 变量\n\n- 动态类型， 变量无类型， 值才有类型\n- 区分大小写\n- 不要以'_大写字母'开头命名变量，这是lua 内部变量的全名规则\n- 未初始化的变量的值为nil (demo)\n- 多重赋值， 可以不对称 (demo)\n\n##数据类型\n\n- 共8种数据类型\n- 都是一等公民，可以做作为参数， 也可以作为返回值\n\n###number\n\n    数值类型， 1.2, 10等\n    lua 5.3之前， 无论是整形还是浮点运算时都转换成浮点型\n\n###string\n\n    \"hello\", \"hello\\n world\"\n\n###boolean\n\n    true, false\n    只有nil, false的值为假，其它值都为正\n    *注意: 0， \"\"， {}的值都是true*\n\n###table\n\n    存储键、值对，\n    {\n        key = value,\n        key = value,\n        ...\n    }\n    键可以为除了nil以外的其它任意类型\n    当键对应的值为nil时，这对键值会被忽略\n\n\n    ``` lua\n        info = {\n            name = \"uniflor\",\n            4 = \"TianJin\",\n            callback = function()\n                print(\"ok\")\n            end,\n            status = true,\n            size = {\n                width = 200,\n                height = 100\n            }\n        }\n    ```\n\n    *在对table进行遍历时，字符串索引的元素位置与书写的顺序无关*\n\n###function\n\n    *同其它语言中的函数*\n    *两种定义方式*\n    *参数可变，按顺序对应*\n    *可以返回多个值*\n\n    ``` lua\n        function test()\n            local a = 1\n            local b = 2\n            return a, b\n        end\n\n        local test = function(x, y)\n            local a = 1 + x\n            local b = 2 + y\n            return a, b\n        end\n    ```\n\n###nil\n\n    定义变量，不赋值时，系统会自动赋值 nil\n    变量没有值，变量未定义，记住写法，\"nil\"\n\n###userdata\n\n    代表c中内存的一块原生数据或指向原生数据的指针\n\n###thread\n\n    Lua中协程程序中的线程，与所运行的平台无关\n\n\n与类型相关的方法：\n    - type\n\n-------\n\n## 关键词\n\n    and       break     do        else      elseif    end\n    false     for       function  goto      if        in\n    local     nil       not       or        repeat    return\n    then      true      until     while\n\n## 语法标记\n\n    +     -     *     /     %     ^     #\n    &     ~     |     <<    >>    //\n    ==    ~=    <=    >=    <     >     =\n    (     )     {     }     [     ]     ::\n    ;     :     ,     .     ..    ...\n\n*与其它语言不同的地方：*\n\n* //\n* ~=\n* \\#\n* ..\n* ...\n\n## 运算符\n  \n* +: 加\n* -: 减\n* *: 乘\n* /: 除\n* //: 取商运算\n* %: 取余运算\n* ^: 乘方\n* -: 一元减\n\n## 逻辑运算\n\n* and 逻辑与\n* or  逻辑或\n* not 逻辑非\n\n*没有&&, ||, !操作符*\n\n* ==: 相等 先判断类型是否相同，再判断值是否相同\n* ~=: 不相等\n* <: 小于\n* \\>: 大于\n* <=: 小于等于\n* \\>=: 大于等于\n\n``` lua\n    if id >= 10 and price <5 then\n        print(\"\")\n    end\n    \n    local exist = false\n    if not exist then\n        print(\"do not exist\")\n    end\n```\n\n\n## 流程控制\n\n- if-else-end 结构\n\n    *注意语句体前面的then，这与java, C不同*\n\n    ``` lua\n    local a\n    if a > 100 then\n        ...\n    elseif a > 50 then\n        ...\n    else\n        ...\n    end\n    ```\n\n- while-do-end 结构\n\n    *在while-do-end中可以使用break跳出循环，但没有continue语句*\n\n    ``` lua\n    local a = 10\n    while a > 0 do\n        ...\n        a = a - 1\n    end\n    ```\n\n- repeat-until 结构\n\n    *在repeat-until中，until之后的表达式与repeat中的语句在一个语句体中，所以在until中可以引用repeat中语句块的局部变量, 而在while-do-end结构中不行*\n\n    ``` lua\n    local u = 10\n    repeat\n        ...\n        u = u - 1\n    until u < 0\n    ```\n\n    ``` lua\n    local u = 10\n    repeat\n        local j = u\n        u = u - 1\n        print(j)\n    until j < 0\n    ```\n\n- for-do-end 结构\n\n    *第一个参数是起始值*\n    *第二个参数是终止值*\n    *第三个参数是步进值, 可以省略，默认为1*\n    *循环变量前虽没有local修饰，但也是for-do-end语句体中的局部变量*\n\n    ``` lua\n    for i = 1, 10, 3 do\n        print(i)\n    end\n    print(i)\n    ```\n\n\n- for-in-do-end 结构\n\n    *lua中两种table的遍历结构*\n    *ipairs()只遍历table中以数字为索引的元素*\n    *paires()遍历table中所有的元素*\n\n    ``` lua\n    local user = {12, 14, 15, name = \"max\"}\n    for i,v in ipairs(user) do\n        print(i,v)\n    end\n    ```\n\n    ``` lua\n    local user = {12, 14, 15, name = \"max\"}\n    for k,v in pairs(user) do\n        print(k,v)\n    end\n    ```\n\n\n\n","source":"_posts/Lua教程1.md","raw":"title: \"Lua教程一\"\ndate: 2015-05-04 22:38:09\nlayout: post\ncomments: true\ncategories:\n- 语言\n- LUA\n---\n\n## 变量\n\n- 动态类型， 变量无类型， 值才有类型\n- 区分大小写\n- 不要以'_大写字母'开头命名变量，这是lua 内部变量的全名规则\n- 未初始化的变量的值为nil (demo)\n- 多重赋值， 可以不对称 (demo)\n\n##数据类型\n\n- 共8种数据类型\n- 都是一等公民，可以做作为参数， 也可以作为返回值\n\n###number\n\n    数值类型， 1.2, 10等\n    lua 5.3之前， 无论是整形还是浮点运算时都转换成浮点型\n\n###string\n\n    \"hello\", \"hello\\n world\"\n\n###boolean\n\n    true, false\n    只有nil, false的值为假，其它值都为正\n    *注意: 0， \"\"， {}的值都是true*\n\n###table\n\n    存储键、值对，\n    {\n        key = value,\n        key = value,\n        ...\n    }\n    键可以为除了nil以外的其它任意类型\n    当键对应的值为nil时，这对键值会被忽略\n\n\n    ``` lua\n        info = {\n            name = \"uniflor\",\n            4 = \"TianJin\",\n            callback = function()\n                print(\"ok\")\n            end,\n            status = true,\n            size = {\n                width = 200,\n                height = 100\n            }\n        }\n    ```\n\n    *在对table进行遍历时，字符串索引的元素位置与书写的顺序无关*\n\n###function\n\n    *同其它语言中的函数*\n    *两种定义方式*\n    *参数可变，按顺序对应*\n    *可以返回多个值*\n\n    ``` lua\n        function test()\n            local a = 1\n            local b = 2\n            return a, b\n        end\n\n        local test = function(x, y)\n            local a = 1 + x\n            local b = 2 + y\n            return a, b\n        end\n    ```\n\n###nil\n\n    定义变量，不赋值时，系统会自动赋值 nil\n    变量没有值，变量未定义，记住写法，\"nil\"\n\n###userdata\n\n    代表c中内存的一块原生数据或指向原生数据的指针\n\n###thread\n\n    Lua中协程程序中的线程，与所运行的平台无关\n\n\n与类型相关的方法：\n    - type\n\n-------\n\n## 关键词\n\n    and       break     do        else      elseif    end\n    false     for       function  goto      if        in\n    local     nil       not       or        repeat    return\n    then      true      until     while\n\n## 语法标记\n\n    +     -     *     /     %     ^     #\n    &     ~     |     <<    >>    //\n    ==    ~=    <=    >=    <     >     =\n    (     )     {     }     [     ]     ::\n    ;     :     ,     .     ..    ...\n\n*与其它语言不同的地方：*\n\n* //\n* ~=\n* \\#\n* ..\n* ...\n\n## 运算符\n  \n* +: 加\n* -: 减\n* *: 乘\n* /: 除\n* //: 取商运算\n* %: 取余运算\n* ^: 乘方\n* -: 一元减\n\n## 逻辑运算\n\n* and 逻辑与\n* or  逻辑或\n* not 逻辑非\n\n*没有&&, ||, !操作符*\n\n* ==: 相等 先判断类型是否相同，再判断值是否相同\n* ~=: 不相等\n* <: 小于\n* \\>: 大于\n* <=: 小于等于\n* \\>=: 大于等于\n\n``` lua\n    if id >= 10 and price <5 then\n        print(\"\")\n    end\n    \n    local exist = false\n    if not exist then\n        print(\"do not exist\")\n    end\n```\n\n\n## 流程控制\n\n- if-else-end 结构\n\n    *注意语句体前面的then，这与java, C不同*\n\n    ``` lua\n    local a\n    if a > 100 then\n        ...\n    elseif a > 50 then\n        ...\n    else\n        ...\n    end\n    ```\n\n- while-do-end 结构\n\n    *在while-do-end中可以使用break跳出循环，但没有continue语句*\n\n    ``` lua\n    local a = 10\n    while a > 0 do\n        ...\n        a = a - 1\n    end\n    ```\n\n- repeat-until 结构\n\n    *在repeat-until中，until之后的表达式与repeat中的语句在一个语句体中，所以在until中可以引用repeat中语句块的局部变量, 而在while-do-end结构中不行*\n\n    ``` lua\n    local u = 10\n    repeat\n        ...\n        u = u - 1\n    until u < 0\n    ```\n\n    ``` lua\n    local u = 10\n    repeat\n        local j = u\n        u = u - 1\n        print(j)\n    until j < 0\n    ```\n\n- for-do-end 结构\n\n    *第一个参数是起始值*\n    *第二个参数是终止值*\n    *第三个参数是步进值, 可以省略，默认为1*\n    *循环变量前虽没有local修饰，但也是for-do-end语句体中的局部变量*\n\n    ``` lua\n    for i = 1, 10, 3 do\n        print(i)\n    end\n    print(i)\n    ```\n\n\n- for-in-do-end 结构\n\n    *lua中两种table的遍历结构*\n    *ipairs()只遍历table中以数字为索引的元素*\n    *paires()遍历table中所有的元素*\n\n    ``` lua\n    local user = {12, 14, 15, name = \"max\"}\n    for i,v in ipairs(user) do\n        print(i,v)\n    end\n    ```\n\n    ``` lua\n    local user = {12, 14, 15, name = \"max\"}\n    for k,v in pairs(user) do\n        print(k,v)\n    end\n    ```\n\n\n\n","slug":"Lua教程1","published":1,"updated":"2015-05-05T04:41:40.000Z","photos":[],"link":"","_id":"ci9e26wr8000of2ar1326t527"},{"title":"Git教程","date":"2015-04-29T06:40:00.000Z","updated":"2015-05-04T05:00:59.000Z","layout":"post","comments":1,"_content":"\n## 常用命令\n\n- add        Add file contents to the index\n- bisect     Find by binary search the change that introduced a bug\n- branch     List, create, or delete branches\n- checkout   Checkout a branch or paths to the working tree\n- clone      Clone a repository into a new directory\n- commit     Record changes to the repository\n- diff       Show changes between commits, commit and working tree, etc\n- fetch      Download objects and refs from another repository\n- grep       Print lines matching a pattern\n- init       Create an empty Git repository or reinitialize an existing one\n- log        Show commit logs\n- merge      Join two or more development histories together\n- mv         Move or rename a file, a directory, or a symlink\n- pull       Fetch from and integrate with another repository or a local branch\n- push       Update remote refs along with associated objects\n- rebase     Forward-port local commits to the updated upstream head\n- reset      Reset current HEAD to the specified state\n- rm         Remove files from the working tree and from the index\n- show       Show various types of objects\n- status     Show the working tree status\n- tag        Create, list, delete or verify a tag object signed with GPG\n\n\n## 创建仓库\n\n- 创建仓库目录\n\n    创建一个目录来作为git的仓库目录\n    *mkdir gitdemo*\n\n- 仓库初始化\n\n    进入仓库目录，使用git命令对仓库进行初始化\n    *cd gitdemo*\n    *git init*\n\n- 添加文件\n\n    添加文件到仓库目录，如:添加文件readme\n\n- 添加文件到版本控制\n\n    添加到仓库的文件还没有在git的版本控制之下，要想对readme文件的改动\n    能被git记录，需要把文件添加到版本控制。\n    *git add readme*\n\n- 提交记录到版本库\n\n    把文件的修改信息添加到版本库\n    *git commit -m \"commit description*\n\n- 修改文件\n\n    对文件readme进行修改\n\n- 添加改动记录\n\n    再次执行*git add readme*, 把对文件的改动添加到版本控制\n\n- 提交改动\n\n    *git commit -m \"second commit\"*\n\n- 还原到上一版本\n\n    *git reset --hard HEAD^*\n    如果知道上一个版本的commmit id 可以指定id进行还原:\n    *git rest --hard ee3b344*\n    在这不用输入完整的commit id,只需前几位即可，git会自己查找对应的记录\n\n- 后悔了\n\n    如果再想回到最后一个版本，而且当前窗口还没有关闭，只要有最后一次提交的\n    commit id, 使用命令*git reset --hard xxxxxx*,还是可以回去最后一\n    个版本的。\n\n    但如果终端窗口已关闭，找不到了最后一次的commit id怎么办？运行命令\n    *git log*, 发现也没了最后一次的记录,这可如果是好?\n    其实所有的commit id 也是有log的。\n    *git reflog*\n\n","source":"_posts/Git教程.md","raw":"title: \"Git教程\"\ndate: 2015-04-29 14:40:00\nupdated:\nlayout: post\ncomments:   true\ncategories:\n- 工具\n- Git\ntags:\n---\n\n## 常用命令\n\n- add        Add file contents to the index\n- bisect     Find by binary search the change that introduced a bug\n- branch     List, create, or delete branches\n- checkout   Checkout a branch or paths to the working tree\n- clone      Clone a repository into a new directory\n- commit     Record changes to the repository\n- diff       Show changes between commits, commit and working tree, etc\n- fetch      Download objects and refs from another repository\n- grep       Print lines matching a pattern\n- init       Create an empty Git repository or reinitialize an existing one\n- log        Show commit logs\n- merge      Join two or more development histories together\n- mv         Move or rename a file, a directory, or a symlink\n- pull       Fetch from and integrate with another repository or a local branch\n- push       Update remote refs along with associated objects\n- rebase     Forward-port local commits to the updated upstream head\n- reset      Reset current HEAD to the specified state\n- rm         Remove files from the working tree and from the index\n- show       Show various types of objects\n- status     Show the working tree status\n- tag        Create, list, delete or verify a tag object signed with GPG\n\n\n## 创建仓库\n\n- 创建仓库目录\n\n    创建一个目录来作为git的仓库目录\n    *mkdir gitdemo*\n\n- 仓库初始化\n\n    进入仓库目录，使用git命令对仓库进行初始化\n    *cd gitdemo*\n    *git init*\n\n- 添加文件\n\n    添加文件到仓库目录，如:添加文件readme\n\n- 添加文件到版本控制\n\n    添加到仓库的文件还没有在git的版本控制之下，要想对readme文件的改动\n    能被git记录，需要把文件添加到版本控制。\n    *git add readme*\n\n- 提交记录到版本库\n\n    把文件的修改信息添加到版本库\n    *git commit -m \"commit description*\n\n- 修改文件\n\n    对文件readme进行修改\n\n- 添加改动记录\n\n    再次执行*git add readme*, 把对文件的改动添加到版本控制\n\n- 提交改动\n\n    *git commit -m \"second commit\"*\n\n- 还原到上一版本\n\n    *git reset --hard HEAD^*\n    如果知道上一个版本的commmit id 可以指定id进行还原:\n    *git rest --hard ee3b344*\n    在这不用输入完整的commit id,只需前几位即可，git会自己查找对应的记录\n\n- 后悔了\n\n    如果再想回到最后一个版本，而且当前窗口还没有关闭，只要有最后一次提交的\n    commit id, 使用命令*git reset --hard xxxxxx*,还是可以回去最后一\n    个版本的。\n\n    但如果终端窗口已关闭，找不到了最后一次的commit id怎么办？运行命令\n    *git log*, 发现也没了最后一次的记录,这可如果是好?\n    其实所有的commit id 也是有log的。\n    *git reflog*\n\n","slug":"Git教程","published":1,"photos":[],"link":"","_id":"ci9e26wrb000rf2ar10l4wb48"},{"title":"Apache AutoIndex 美化","date":"2015-04-30T03:29:11.000Z","_content":"\n通过Apache搭建网页服务器，但开启了某个目录的autoindex功能时，可以很方便的实现文件共享。\n但apache默认生成的界面看起来实在太丑。我们可以配置http.conf来配置生成界面的样式， 但如果你不了apache的配置，不了解html和css， 操作起来也是很不方便。\n\ngithub上的一个开源项目Apaxy正好解决了这个问题。\n    \n[Apaxy](https://github.com/AdamWhitcroft/Apaxy)\n\nApaxy主要功能：\n\n\n- 使用 CSS 美化目录浏览。\n- 可以使用 JavaScript 或者 jQuery 方式弹窗。\n- 可以添加欢迎消息，下载指示和版权信息。\n- 添加自定义文件类型图标（需要修改 .htaccess 文件）。\n\n具体使用方法，参考github上面的项目说明。\n\n","source":"_posts/Apache-AutoIndex-美化.md","raw":"title: \"Apache AutoIndex 美化\"\ndate: 2015-04-30 11:29:11\ncategories:\n- 服务器\ntags:\n---\n\n通过Apache搭建网页服务器，但开启了某个目录的autoindex功能时，可以很方便的实现文件共享。\n但apache默认生成的界面看起来实在太丑。我们可以配置http.conf来配置生成界面的样式， 但如果你不了apache的配置，不了解html和css， 操作起来也是很不方便。\n\ngithub上的一个开源项目Apaxy正好解决了这个问题。\n    \n[Apaxy](https://github.com/AdamWhitcroft/Apaxy)\n\nApaxy主要功能：\n\n\n- 使用 CSS 美化目录浏览。\n- 可以使用 JavaScript 或者 jQuery 方式弹窗。\n- 可以添加欢迎消息，下载指示和版权信息。\n- 添加自定义文件类型图标（需要修改 .htaccess 文件）。\n\n具体使用方法，参考github上面的项目说明。\n\n","slug":"Apache-AutoIndex-美化","published":1,"updated":"2015-05-04T05:00:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ci9e26wre000vf2ar1p3nho3s"},{"title":"AndroidStudio代理设置","date":"2015-05-06T01:57:42.000Z","_content":"\nAndroid Studio 第一次启动时会检测Android SDK的信息，无奈有GFW的阻挡，即使翻墙，下载速度也让人抓狂，还好国内有几个不错的镜像网站。\n\n## 禁用第一次启动时检测SDK信息\n\n打开Android Studio之前，找到Android Studio的配置文件idea.properties, 在android-studio/bin目录下，在这个文件的最后一行*添加*一行：\n\n>disable.android.first.run=true\n\n然后打开Android Studio, 进入Configure->SDK Manager, 设置代理。设置完成后关闭Android Studio。\n\n如果想修改Android Studio的代理，进入Configure->Settings->HTTP Proxy settings。\n\n再*删掉*刚才添加的那一行，保存后再重新打开Android Studio。\n\n## 修改Android Studio代理\n\n如果Android Studio已经运行过，即使是第一次运行失败，会生成Android Studio的配置文件夹，UNIX系统下路径为：~/.AndroidStudio/, 找到config/options/other.xml, 对下面几行进行设置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<application>\n  <component name=\"HttpConfigurable\">\n    <option name=\"USE_HTTP_PROXY\" value=\"true\" />\n    <option name=\"PROXY_HOST\" value=\"127.0.0.1\" />\n    <option name=\"PROXY_PORT\" value=\"3128\" />\n  </component>\n</application>\n```\n\n\n","source":"_posts/AndroidStudio代理设置.md","raw":"title: \"AndroidStudio代理设置\"\ndate: 2015-05-06 09:57:42\ncategories:\n- Android\ntags:\n---\n\nAndroid Studio 第一次启动时会检测Android SDK的信息，无奈有GFW的阻挡，即使翻墙，下载速度也让人抓狂，还好国内有几个不错的镜像网站。\n\n## 禁用第一次启动时检测SDK信息\n\n打开Android Studio之前，找到Android Studio的配置文件idea.properties, 在android-studio/bin目录下，在这个文件的最后一行*添加*一行：\n\n>disable.android.first.run=true\n\n然后打开Android Studio, 进入Configure->SDK Manager, 设置代理。设置完成后关闭Android Studio。\n\n如果想修改Android Studio的代理，进入Configure->Settings->HTTP Proxy settings。\n\n再*删掉*刚才添加的那一行，保存后再重新打开Android Studio。\n\n## 修改Android Studio代理\n\n如果Android Studio已经运行过，即使是第一次运行失败，会生成Android Studio的配置文件夹，UNIX系统下路径为：~/.AndroidStudio/, 找到config/options/other.xml, 对下面几行进行设置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<application>\n  <component name=\"HttpConfigurable\">\n    <option name=\"USE_HTTP_PROXY\" value=\"true\" />\n    <option name=\"PROXY_HOST\" value=\"127.0.0.1\" />\n    <option name=\"PROXY_PORT\" value=\"3128\" />\n  </component>\n</application>\n```\n\n\n","slug":"AndroidStudio代理设置","published":1,"updated":"2015-05-06T02:22:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ci9e26ws3000yf2arfciyhfy5"},{"title":"中科院Android SDK镜像","date":"2015-04-29T07:00:00.000Z","updated":"2015-05-04T05:00:09.000Z","layout":"post","comments":1,"_content":"\n# 使用方法\n\n+ 启动 Android SDK Manager ，打开主界面\n+ 依次选择『Tools』、『Options』，弹出『Android SDK Manager - Settings』窗口\n+ 在『Settings』窗口中，在『HTTP Proxy Server』输入框内填入：mirrors.opencas.cn， \n+ 在『HTTP Proxy Port』输入框内填入：80\n+ 并且选中『Force https:// ... 』复选框。设置完成后单击『Close』按钮关闭\n+ 依次选择『Packages』、『Reload』。","source":"_posts/Android SDK国内镜像.md","raw":"title: \"中科院Android SDK镜像\"\ndate: 2015-04-29 15:00:00\nupdated:\nlayout: post\ncomments:   true\ncategories:\n- Android\ntags:\n---\n\n# 使用方法\n\n+ 启动 Android SDK Manager ，打开主界面\n+ 依次选择『Tools』、『Options』，弹出『Android SDK Manager - Settings』窗口\n+ 在『Settings』窗口中，在『HTTP Proxy Server』输入框内填入：mirrors.opencas.cn， \n+ 在『HTTP Proxy Port』输入框内填入：80\n+ 并且选中『Force https:// ... 』复选框。设置完成后单击『Close』按钮关闭\n+ 依次选择『Packages』、『Reload』。","slug":"Android SDK国内镜像","published":1,"photos":[],"link":"","_id":"ci9e26ws60011f2aretq3ezr1"},{"title":"nginx","_content":"","source":"_drafts/nginx.md","raw":"title: \"nginx\"\ntags:\n---\n","slug":"nginx","published":0,"date":"2015-05-06T08:08:15.000Z","updated":"2015-05-06T08:08:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ci9e26ws80013f2ark2qf6ct5"},{"title":"Apache 重定向","_content":"","source":"_drafts/Apache-重定向.md","raw":"title: \"Apache 重定向\"\ntags:\n---\n","slug":"Apache-重定向","published":0,"date":"2015-05-05T05:33:21.000Z","updated":"2015-05-05T05:33:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ci9e26wsa0014f2ar5b4glpew"},{"title":"booting in insecure mode","date":"2015-05-06T13:03:52.000Z","_content":"\n最新安装了Ubuntu 15.04, 发现启动时屏幕显示\"Booting in insecure mode\", 网上一番搜索，发现这是Ubuntu 14.10引入的一个Bug, 在15.04还没有修复。这行文字会显示3秒，然后自动消失，对系统的使用没有什么影响。但如果你看着不爽，要把它去掉，可以缷载掉shim。\n\n``` sh\nsudo apt-get purge shim shim-signed\nsudo grub-install\n```\n\n重启电脑，整个世界都清净了。（强迫症就是这样养成的）\n","source":"_posts/BootingInInsecureMode.md","raw":"title: \"booting in insecure mode\"\ndate: 2015-05-06 21:03:52\ncategories:\n- 系统\n- Ubuntu\ntags:\n---\n\n最新安装了Ubuntu 15.04, 发现启动时屏幕显示\"Booting in insecure mode\", 网上一番搜索，发现这是Ubuntu 14.10引入的一个Bug, 在15.04还没有修复。这行文字会显示3秒，然后自动消失，对系统的使用没有什么影响。但如果你看着不爽，要把它去掉，可以缷载掉shim。\n\n``` sh\nsudo apt-get purge shim shim-signed\nsudo grub-install\n```\n\n重启电脑，整个世界都清净了。（强迫症就是这样养成的）\n","slug":"BootingInInsecureMode","published":1,"updated":"2015-05-07T12:04:05.000Z","_id":"ci9e4iva000003xn3tcn1yy14","comments":1,"layout":"post","photos":[],"link":""}],"PostAsset":[],"PostCategory":[{"post_id":"ci9e26vrw0001f2ar9likt6d1","category_id":"ci9e26vrz0002f2arivo64fd4","_id":"ci9e26vs20004f2arnizh1jhp"},{"post_id":"ci9e26vrw0001f2ar9likt6d1","category_id":"ci9e26vs10003f2arwpug281o","_id":"ci9e26vs20005f2ark8b2jbnx"},{"post_id":"ci9e26vsl000cf2aru0vqtkid","category_id":"ci9e26vrz0002f2arivo64fd4","_id":"ci9e26vsm000ef2ar3r2fmhg0"},{"post_id":"ci9e26vsl000cf2aru0vqtkid","category_id":"ci9e26vsm000df2arbjecx9kg","_id":"ci9e26vsm000ff2arkgcm6hng"},{"post_id":"ci9e26wje000gf2argn2pglr9","category_id":"ci9e26wjg000hf2ar4y5o1wad","_id":"ci9e26wjh000jf2arozvq37vn"},{"post_id":"ci9e26wje000gf2argn2pglr9","category_id":"ci9e26wjg000if2arteylr43j","_id":"ci9e26wjh000kf2artm1mkypy"},{"post_id":"ci9e26wr4000lf2ar9gnl6jy6","category_id":"ci9e26wjg000hf2ar4y5o1wad","_id":"ci9e26wr5000mf2arpy04wg3f"},{"post_id":"ci9e26wr4000lf2ar9gnl6jy6","category_id":"ci9e26wjg000if2arteylr43j","_id":"ci9e26wr6000nf2arrno1h344"},{"post_id":"ci9e26wr8000of2ar1326t527","category_id":"ci9e26wjg000hf2ar4y5o1wad","_id":"ci9e26wr9000pf2ar20qvqmtl"},{"post_id":"ci9e26wr8000of2ar1326t527","category_id":"ci9e26wjg000if2arteylr43j","_id":"ci9e26wr9000qf2arsg0f9gv3"},{"post_id":"ci9e26wrb000rf2ar10l4wb48","category_id":"ci9e26vse0008f2arhmpw9tsh","_id":"ci9e26wrc000tf2arzkhja04f"},{"post_id":"ci9e26wrb000rf2ar10l4wb48","category_id":"ci9e26wrc000sf2arb7sljylo","_id":"ci9e26wrd000uf2arnok5qbws"},{"post_id":"ci9e26wre000vf2ar1p3nho3s","category_id":"ci9e26wrg000wf2arnswgupr7","_id":"ci9e26wrg000xf2armblciv2b"},{"post_id":"ci9e26ws3000yf2arfciyhfy5","category_id":"ci9e26ws4000zf2arw3dg518w","_id":"ci9e26ws50010f2aro390uxbm"},{"post_id":"ci9e26ws60011f2aretq3ezr1","category_id":"ci9e26ws4000zf2arw3dg518w","_id":"ci9e26ws70012f2arbznk05nd"},{"post_id":"ci9e26vsd0007f2ar4khxiewa","category_id":"ci9e26vse0008f2arhmpw9tsh","_id":"ci9e2f4sh000af4aro31dtmyq"},{"post_id":"ci9e26vsd0007f2ar4khxiewa","category_id":"ci9e26vse0009f2aramollh1h","_id":"ci9e2f4sh000bf4arujviurj0"},{"post_id":"ci9e26vs80006f2armec0wvt3","category_id":"ci9e26ws4000zf2arw3dg518w","_id":"ci9e362uo0005fkar025tjc2a"},{"post_id":"ci9e4iva000003xn3tcn1yy14","category_id":"ci9e26vrz0002f2arivo64fd4","_id":"ci9e4lr5o0000ben3qvbju6yf"},{"post_id":"ci9e4iva000003xn3tcn1yy14","category_id":"ci9e26vs10003f2arwpug281o","_id":"ci9e4lr5p0001ben3nutnq98o"}],"PostTag":[],"Tag":[]}}